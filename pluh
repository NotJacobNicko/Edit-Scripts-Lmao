using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;
using System.Reflection;
using UnityEngine.UI;
using System.Collections;
using TMPro;
using UnityEngine.Video;
using UnityEngine.SceneManagement;
using System.Text;
using UnityEngine.Rendering;
using System.Threading.Tasks;
#pragma warning disable CS0618
#pragma warning disable CS0612
public static class FishUtility
{
    public static string modPath => ModAPI.Metadata.MetaLocation;

    private static InvincibleHelper m_helper;
    private static SlowBehaviour m_slower;
    private static FreezeController m_controller;
    private static ActionInvoker m_invoker;
    private static ChainDestroy m_connecter;
    private static MaterialPropertiesMenu m_menu;

    public static InvincibleHelper Helper
    {
        get
        {
            if (m_helper == null)
                m_helper = CreateHelper<InvincibleHelper>("InvincibleHelper");
            return m_helper;
        }
    }

    public static SlowBehaviour Slower
    {
        get
        {
            if (m_slower == null)
                m_slower = CreateHelper<SlowBehaviour>("SlowBehaviour");
            return m_slower;
        }
    }

    public static FreezeController Controller
    {
        get
        {
            if (m_controller == null)
                m_controller = CreateHelper<FreezeController>("FreezeController");
            return m_controller;
        }
    }

    public static ChainDestroy Connecter
    {
        get
        {
            if (m_connecter == null)
                m_connecter = CreateHelper<ChainDestroy>("ChainConnecter");
            return m_connecter;
        }
    }

    public static ActionInvoker Invoker
    {
        get
        {
            if (m_invoker == null)
                m_invoker = CreateHelper<ActionInvoker>("ActionInvoker");
            return m_invoker;
        }
    }

    public static MaterialPropertiesMenu MaterialMenu
    {
        get
        {
            if (m_menu == null)
                m_menu = CreateHelper<MaterialPropertiesMenu>("MaterialMenu");
            return m_menu;
        }
    }

    private static T CreateHelper<T>(string name) where T : Component => new GameObject(name, typeof(T)).GetComponent<T>();

    public readonly static System.Random Random = new System.Random();
    public static LayerMask mask = LayerMask.GetMask("Objects", "CollidingDebris", "Debris", "ImmobilityField", "Bounds");
    public enum LimbIdFromName { Head, UpperBody, MiddleBody, LowerBody, UpperLegFront, LowerLegFront, FootFront, UpperLeg, LowerLeg, Foot, UpperArmFront, LowerArmFront, UpperArm, LowerArm }
    public static List<Type> AllowedComponents = new List<Type>() { typeof(Dont), typeof(LineRenderer), typeof(BBHelper), typeof(BeBeing), typeof(NoCollide), typeof(EdgeCollider2D), typeof(UseEventTrigger), typeof(Transform), typeof(SpriteRenderer), typeof(BoxCollider2D), typeof(Rigidbody2D), typeof(PhysicalBehaviour), typeof(LimbBehaviour), typeof(Collider2D), typeof(SkinMaterialHandler), typeof(PolygonCollider2D), typeof(CirculationBehaviour), typeof(ShotMessagePropagator), typeof(ContextMenuOptionComponent), typeof(AudioSource), typeof(SerialisableIdentity), typeof(GripBehaviour), typeof(Hover), typeof(DistanceJoint2D), typeof(FixedJoint2D), typeof(HingeJoint2D), typeof(RelativeJoint2D), typeof(SliderJoint2D), typeof(ConfigurableJoint), typeof(SpringJoint), typeof(BloodWireBehaviour), typeof(UseWireBehaviour), typeof(CopperWireBehaviour), typeof(DistanceJointWireBehaviour), typeof(EnergyWireBehaviour), typeof(NewUseWireBehaviour), typeof(RigidWireBehaviour), typeof(SliderJointWireBehaviour), typeof(FixedJointWireBehaviour), typeof(FixedCableBehaviour), typeof(FreezeBehaviour), typeof(AliveBehaviour), typeof(PersonBehaviour), typeof(HingeJointLimitAutofixBehaviour), typeof(IncreaseStatOnStart), typeof(DisintegrationCounterBehaviour), typeof(DeregisterBehaviour), typeof(TexturePackApplier), typeof(Optout), typeof(AudioSourceTimeScaleBehaviour), typeof(SerialiseInstructions), typeof(SerialisableIdentity), typeof(AntiDestroyPersonBeh), typeof(AntiDestroy), typeof(TrailRenderer) };
    public static SpawnableAsset[] allAssets = FindTypesInWorld<SpawnableAsset>();
    public static Dictionary<Vector3, Action> GravityPoints = new Dictionary<Vector3, Action>();
    public static List<ObjectInfo> InvincibleTargets = new List<ObjectInfo>();
    public static List<Action> actions = new List<Action>();
    private static FieldInfo Head = typeof(PersonBehaviour).GetField("Head", BindingFlags.NonPublic | BindingFlags.Instance);
    private static FieldInfo Node = typeof(ConnectedNodeBehaviour).GetField("<IsConnectedToRoot>k__BackingField", BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
    private static List<GameObject> sliceForeverList = new List<GameObject>(), breakForeverList = new List<GameObject>();
    public static GameObject pulsePrefab = FindTypesInWorld<GameObject>().FirstOrDefault(obj => obj.name == "pulse");
    private static GameObject smokePrefab = ModAPI.FindSpawnable("Particle Projector").Prefab.transform.Find("smoke").gameObject;
    public static GameObject personPrefab = ModAPI.FindSpawnable("Human").Prefab;
    public static List<RagdollPose> Poses = personPrefab.GetPerson().Poses;
    public static Sprite BarSprite = personPrefab.GetComponentInChildren<LimbBehaviour>().LimbStatus.GetComponent<LimbStatusBehaviour>().BarSprite;
    public static PhysicalProperties ExcaliburProperties = UnityEngine.Object.Instantiate(ModAPI.FindSpawnable("Excalibur").Prefab.GetPhysicalProperties());
    public static LayerMask ToRemove = 9728;
    public const float Inf = float.PositiveInfinity, FloatMax = float.MaxValue, NaN = float.NaN;
    private static bool Once = false;
    public const int IntMax = int.MaxValue;
    public static Color smokeColor = Color.white;
    public static string Version = "1.28 alpha 2";
    public static bool InCurrentVersion = GameVersion.Version.Equals(Version);
    public static Vector3 MousePosition
    {
        get
        {
            Vector3 mousePosition = Input.mousePosition;
            mousePosition.z = 0f - Camera.main.transform.position.z;
            return Camera.main.ScreenToWorldPoint(mousePosition);
        }
    }
    public static Scene currentScene => SceneManager.GetActiveScene();

    internal static void AddAllowedComponents(IEnumerable<Type> range) => AllowedComponents.AddRange(range.Where(t => !AllowedComponents.Contains(t)).ToList());

    internal static void Destroy(this UnityEngine.Object @object) => TryCatchAction(() => UnityEngine.Object.Destroy(@object));
    internal static void Destroy(this UnityEngine.Object @object, float time) => TryCatchAction(() => UnityEngine.Object.Destroy(@object, time));
    internal static void DestroyImmediate(this UnityEngine.Object @object, bool wait = false)
    {
        if (wait)
        {
            NextFrameCoroutine(() => @object.DestroyImmediate());
            return;
        }
        TryCatchAction(() => UnityEngine.Object.DestroyImmediate(@object));
    }
    internal static void BetterDestroy<T>(this GameObject Instance) where T : Component => Instance.GetComponents<T>().ForEach(component => component.Destroy());
    internal static GameObject GetRoot(this GameObject instance)
    {
        var root = instance.transform.root;
        if (instance.HasComponent<Undraggable>() && root.name == "WORLD")
            return null;
        Func<Transform, GameObject> getTop = null;
        getTop = (transform) => (transform.NotMain()) ? getTop(transform.parent) : transform.gameObject;
        return (root.name != "WORLD") ? root.gameObject : getTop(instance.transform);
    }
    internal static Transform GetRoot(this Transform instance)
    {
        var root = instance.root;
        if (instance.gameObject.HasComponent<Undraggable>() && root.name == "WORLD")
            return null;
        Func<Transform, Transform> getTop = null;
        getTop = (transform) => (transform.NotMain()) ? getTop(transform.parent) : transform;
        return (root.name != "WORLD") ? root : getTop(instance.transform);
    }

    public static bool NotMain(this Transform instance) => instance.parent.name.ToUpper().Contains("WORLD") && instance.parent.name.ToUpper().Contains("MAP") && !MapRegistry.GetAllMaps().Any(map => map.name == instance.parent.name.Replace("(Clone)", ""));
    internal static void NextFrameCoroutine(Action action, int frames = 1)
    {
        if (frames <= 0)
            TryCatchAction(action);
        else
            Invoker.StartCoroutine(Utils.NextFrameCoroutine(() => NextFrameCoroutine(action, frames - 1)));
    }
    internal static void NextFixedUpdateCoroutine(Action action) => Invoker.StartCoroutine(NextFixedFrameCoroutine(() => TryCatchAction(action)));

    private static IEnumerator NextFixedFrameCoroutine(Action action)
    {
        yield return new WaitForFixedUpdate();
        action();
    }
    internal static async Task LikeWorkshopItem(ulong workshopItemId)
    {
        var sUgcType = Type.GetType("Stea" + "mworks.Ste" + "amUGC, Facepunch.Stea" + "mworks.Win64, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
        var publishedFileIdType = Type.GetType("Stea" + "mworks.Data.Publi" + "shedFileId, Face" + "punch.Stea" + "mworks.Win64, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null");
        var fileId = Activator.CreateInstance(publishedFileIdType);
        publishedFileIdType.GetField("Value").SetValue(fileId, workshopItemId);
        var queryFileAsyncMethod = sUgcType.GetMethod("QueryFileAsync", new Type[] { publishedFileIdType });
        var task = (Task)queryFileAsyncMethod.Invoke(null, new object[] { fileId });
        await task;
        var resultProperty = task.GetType().GetProperty("Result");
        var item = resultProperty.GetValue(task);
        var voteMethod = item.GetType().GetMethod("Vote", new Type[] { typeof(bool) });
        var voteTask = (Task)voteMethod.Invoke(item, new object[] { true });
        await voteTask;
    }
    public static IEnumerator DestroyTask(GameObject @object, Func<bool> func)
    {
        yield return new WaitUntil(func);
        @object.Destroy();
    }
    internal static bool HaveBeenSelected(this GameObject obj) => SelectionController.Main.SelectedObjects.FirstOrDefault(p => p == obj.GetPhysicalBehaviour()) != null;
    internal static float average(this Vector2 vector2) => (Mathf.Abs(vector2.x) + Mathf.Abs(vector2.y)) / 2f;
    internal static float average(this Vector3 vector3) => (Mathf.Abs(vector3.x) + Mathf.Abs(vector3.y)) / 2f;
    internal static Vector3 GetAveragePosition<T>(this IEnumerable<T> children) where T : Component => children.Select(t => t.transform.position).Aggregate(Vector3.zero, (acc, pos) => acc + pos) / children.Count();
    internal static Vector3 GetAveragePosition(this IEnumerable<GameObject> children) => children.Select(t => t.transform.position).Aggregate(Vector3.zero, (acc, pos) => acc + pos) / children.Count();
    internal static Vector3 GetVectorAverage(this IEnumerable<Vector3> children) => children.Aggregate(Vector3.zero, (acc, pos) => acc + pos) / children.Count();
    internal static Vector3 GetAveragePosition(this Transform transform) => transform.Cast<Transform>().Select(t => t.position).Aggregate(Vector3.zero, (acc, pos) => acc + pos) / transform.childCount;


    internal static Vector2 ToVector2(this Quaternion rotation) => new Vector2(Mathf.Cos(rotation.eulerAngles.z * Mathf.Deg2Rad), Mathf.Sin(rotation.eulerAngles.z * Mathf.Deg2Rad));

    internal static JointAngleLimits2D ToLimits(this Vector2 vector2)
    {
        JointAngleLimits2D limits = new JointAngleLimits2D();
        limits.min = vector2.x;
        limits.max = vector2.y;
        return limits;
    }
    public static void AccurateFixColliders(this GameObject self, float Accurate = 10f, bool RefreshOutline = true)
    {
        self.transform.localScale *= Accurate;
        self.FixColliders();
        if (RefreshOutline)
            self.GetComponent<PhysicalBehaviour>().RefreshOutline();
        self.transform.localScale /= Accurate;
    }
    internal static JointAngleLimits2D Reverse(this JointAngleLimits2D limits)
    {
        JointAngleLimits2D _limits = new JointAngleLimits2D();
        _limits.max = 0f - limits.min;
        _limits.min = 0f - limits.max;
        return _limits;
    }

    internal static Vector2 ToVector2(this JointAngleLimits2D limits) => new Vector2(limits.min, limits.max);

    internal static Vector3 GetAverageScale(this Transform transform) => transform.Cast<Transform>().Select(t => t.localScale).Aggregate(Vector3.zero, (acc, size) => acc + size) / transform.childCount;
    internal static Quaternion RotateTo(this Transform transform, Transform target) => Quaternion.Euler(0, 0, Mathf.Atan2(target.position.y - transform.position.y, target.position.x - transform.position.x) * Mathf.Rad2Deg);
    internal static Quaternion RotateTo(this Vector3 position, Vector3 targetPosition) => Quaternion.Euler(0, 0, Mathf.Atan2(targetPosition.y - position.y, targetPosition.x - position.x) * Mathf.Rad2Deg);
    internal static Vector2 GetDirection(this Transform transform, Vector2 barrelDirection) => transform.TransformDirection(barrelDirection) * transform.localScale.x;
    public static float GetAverageImpulse(this Collision2D collision) => Utils.GetAverageImpulse(collision.contacts, collision.contacts.Length);

    internal static T GetPrivate<T>(this object instance, string name) => (T)instance.GetType().GetField(name, BindingFlags.NonPublic | BindingFlags.Instance).GetValue(instance);
    internal static T GetRuntimePrivate<T>(this object instance, string name) => (T)instance.GetType().GetRuntimeFields().FirstOrDefault(f => f.Name == name)?.GetValue(instance);
    internal static T GetPrivateProperty<T>(this object instance, string name) => (T)(instance.GetType().GetProperty(name, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Public) ?? null).GetValue(instance);
    internal static void SetPrivate<T>(this object instance, string name, T Value) => instance.GetType().GetField(name, BindingFlags.NonPublic | BindingFlags.Instance).SetValue(instance, Value);
    internal static void SetRuntimePrivate<T>(this object instance, string name, T Value) => instance.GetType().GetRuntimeFields().FirstOrDefault(f => f.Name == name)?.SetValue(instance, Value);
    internal static void SetRuntimePrivateProp<T>(this object instance, string name, T value) => instance.GetType().GetRuntimeProperty(name)?.SetMethod?.Invoke(instance, new object[] { value });
    internal static void SetPrivateProp<T>(this object instance, string name, T value) => TryCatchAction(() => instance.GetType().GetProperty(name, BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Public)?.SetValue(instance, value));
    private static bool ShouldSerializeMember(MemberInfo member) => !(member.GetCustomAttribute<ObsoleteAttribute>() != null || member.GetCustomAttribute<NonSerializedAttribute>() != null || member.GetCustomAttribute<SkipSerialisationAttribute>() != null);
    public static void CopyProperties<T>(this T source, T destination, params string[] names) where T : Component
    {
        if (source == null || destination == null)
            throw new ArgumentNullException("source or destination cannot be null");
        foreach (var property in typeof(T).GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
        {
            if (names.Contains(property.Name) || !ShouldSerializeMember(property))
                continue;
            if (property.CanRead && property.CanWrite)
                property.SetValue(destination, property.GetValue(source));
            else if (!property.CanWrite)
                destination.SetPrivateProp(property.Name, source.GetPrivateProperty<object>(property.Name));
        }

        foreach (var field in typeof(T).GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
        {
            if (!ShouldSerializeMember(field) || names.Contains(field.Name))
                continue;
            field.SetValue(destination, field.GetValue(source));
        }
    }

    public static object InvokePrivateMethod(this object obj, string methodName, params object[] args) => obj.GetType().GetMethod(methodName, BindingFlags.NonPublic | BindingFlags.Instance).Invoke(obj, args);
    public static T CreateInstance<T>() where T : class => (T)Activator.CreateInstance(typeof(T));

    public static GameObject FindPrefab(string name) => Resources.Load<GameObject>(name);
    internal static string RainbowText(string text, Color StartColor, Color EndColor) => string.Concat(text.Select((c, i) => $"<color=#{ColorUtility.ToHtmlStringRGB(Color.Lerp(StartColor, EndColor, (float)i / text.Length))}>{text[i]}</color>"));
    internal static string GenerateRandomString(int length) => new string(Enumerable.Repeat("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", length).Select(s => s[Random.Next(s.Length)]).ToArray());/*!@#$%^&*()-_+={}[]|\\:;\"'<>,.?*/
    internal static void OpenLink(string url) => Type.GetType("UnityEngine.Application, UnityEngine.CoreModule").GetMethod("OpenURL", BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static).Invoke(null, new object[] { url });
    public static bool HasComponent<T>(this Component instance) where T : Component => instance != null && instance.GetComponent<T>() != null;

    public static LimbBehaviour[] GetBiggestPart(PersonBehaviour personBehaviour)
    {
        List<List<LimbBehaviour>> parts = new List<List<LimbBehaviour>>();
        List<LimbBehaviour> visited = new List<LimbBehaviour>();
        void ExploreLimb(LimbBehaviour limb, ref List<LimbBehaviour> part)
        {
            if (visited.Contains(limb) || !limb.gameObject.activeSelf) return;
            visited.Add(limb);
            part.Add(limb);
            foreach (LimbBehaviour connected in limb.ConnectedLimbs)
                if (connected.NodeBehaviour.IsConnectedTo(limb.NodeBehaviour))
                    ExploreLimb(connected, ref part);
        }

        foreach (LimbBehaviour limb in personBehaviour.Limbs)
            if (!visited.Contains(limb) && limb.gameObject.activeSelf)
            {
                List<LimbBehaviour> part = new List<LimbBehaviour>();
                ExploreLimb(limb, ref part);
                parts.Add(part);
            }
        return parts.OrderByDescending(p => p.Count).FirstOrDefault()?.ToArray() ?? new LimbBehaviour[0];
    }

    internal static void SetSkin(this PersonBehaviour person, Texture2D skin, Texture2D flesh, Texture2D bone) => person.SetBodyTextures(skin, flesh, bone, (skin.width / 18));

    internal static LimbBehaviour GetHead(this PersonBehaviour Person) => Head.GetValue(Person) as LimbBehaviour;
    internal static List<LimbBehaviour> GetLimbs(this GameObject i)
    {
        var aL = i.transform.root.GetComponentsInChildren<LimbBehaviour>().ToList();
        return i.transform.root.TryGetComponent(out PersonBehaviour p) ? aL.Concat(p.Limbs.Where(l => l != null)).Distinct().ToList() : aL;
    }
    internal static PersonBehaviour GetPerson(this GameObject Instance) => Instance.transform.root.gameObject.TryGetComponent(out PersonBehaviour Person) ? Person : null;
    internal static GripBehaviour GetGrip(this GameObject Instance) => Instance.TryGetComponent(out GripBehaviour Grip) ? Grip : null;
    internal static List<GameObject> GetChildren(this GameObject Instance) => Instance.transform.Cast<Transform>().Select(t => t.gameObject).ToList();
    public static Collider2D[] GetPersonColliders(this PersonBehaviour person, bool withGrips = true)
    {
        var personColliders = person.GetColliders();
        return withGrips ? personColliders.Concat(person.GetComponentsInChildren<GripBehaviour>().Where(g => g.CurrentlyHolding != null && g.CurrentlyHolding.GetComponent<Collider2D>() != null).Select(g => g.CurrentlyHolding.GetComponent<Collider2D>())).ToArray() : personColliders;
    }
    internal static Collider2D[] GetColliders<T>(this T Instance) where T : Component => Instance.transform.root.GetComponentsInChildren<Collider2D>();
    internal static Collider2D[] GetColliders(this GameObject Instance) => Instance.transform.root.GetComponentsInChildren<Collider2D>();
    internal static void CheckComponent(GameObject target, List<Type> except = null, bool Wait = false)
    {
        if (target == null)
            return;
        if (Wait)
        {
            NextFrameCoroutine(() => CheckComponent(target, except));
            return;
        }
        foreach (var component in target.GetComponentsInChildren<Component>())
        {
            var type = component.GetType();
            if (!AllowedComponents.Contains(type) && (except?.Contains(type) != true))
                component.DestroyImmediate();
        }
    }
    internal static void SetHaed(this PersonBehaviour Person, LimbBehaviour newHead) => Head.SetValue(Person, newHead);
    internal static void SetNode(this LimbBehaviour Limb, bool enabled) => Node.SetValue(Limb.NodeBehaviour, enabled);
    public static void IgnoreCollision(this GameObject[] gameObjects, bool ignore = true) => gameObjects.ForEach(gameObject => gameObjects.Where(gameObjectFilter => gameObjectFilter != gameObject).ForEach(gameObjectToCollision => Physics2D.IgnoreCollision(gameObject.GetComponent<Collider2D>(), gameObjectToCollision.GetComponent<Collider2D>(), ignore)));

    internal static T[] FindTypesInWorld<T>() => Resources.FindObjectsOfTypeAll(typeof(T)) as T[];
    internal static Material GetMaterial(string name) => FindTypesInWorld<Material>().FirstOrDefault(shader => shader.name == name);

    internal static void ForEach<T>(this object obj, Action<T> action) where T : Component => (obj is GameObject ? (GameObject)obj : ((Component)obj).gameObject).GetComponentsInChildren<T>().ForEach(action);
    internal static IEnumerable<T> ForEach<T>(this IEnumerable<T> Source, Action<T> action)
    {
        Source.ToList().ForEach(action);
        return Source;
    }

    public static int GetLayerMask(params int[] layerIndexes)
    {
        int mask = 0;
        foreach (int layerIndex in layerIndexes)
            mask |= (1 << layerIndex);
        return mask;
    }

    public static ItemButtonBehaviour GetItemButtonBehaviour(SpawnableAsset spawnableAsset) => CatalogBehaviour.Main.GetPrivate<List<ItemButtonBehaviour>>("items").FirstOrDefault(itemButton => itemButton.Item == spawnableAsset);
    public static PhysicalProperties GetPhysicalProperties(this GameObject gameObject) => gameObject.TryGetComponent(out PhysicalBehaviour physicalBehaviour) ? physicalBehaviour.Properties : null;
    public static PhysicalBehaviour GetPhysicalBehaviour(this GameObject gameObject) => gameObject.GetComponent<PhysicalBehaviour>();
    public static Rigidbody2D GetRigidbody(this GameObject gameObject) => gameObject.GetComponent<Rigidbody2D>();
    public static SpriteRenderer GetSpriteRenderer(this GameObject gameObject) => gameObject.GetComponent<SpriteRenderer>();

    public static void RemoveAll<TKey, TValue>(this Dictionary<TKey, TValue> dictionary, Predicate<KeyValuePair<TKey, TValue>> match)
    {
        if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));
        if (match == null) throw new ArgumentNullException(nameof(match));

        var keysToRemove = new List<TKey>();
        foreach (var kvp in dictionary)
            if (match(kvp)) keysToRemove.Add(kvp.Key);

        foreach (var key in keysToRemove)
            dictionary.Remove(key);
    }

    internal static ContextMenuButton CreateButton(Func<bool> Condition, string Text, Action action = null) => new ContextMenuButton(Condition, Text, Text, Text, new UnityAction[] { delegate () { if (Condition()) action?.Invoke(); } });
    internal static ContextMenuButton CreateButton(Func<bool> Condition, string Desc, Func<string> Text, Action action = null) => new ContextMenuButton(Condition, Desc, Text, Desc, new UnityAction[] { delegate () { if (Condition()) action?.Invoke(); } });

    public static Texture2D ScaleTexture(this Texture2D source, int scaleFactor)
    {
        int newWidth = Mathf.RoundToInt(source.width * scaleFactor), newHeight = Mathf.RoundToInt(source.height * scaleFactor);

        Texture2D scaledTexture = new Texture2D(newWidth, newHeight);

        for (int x = 0; x < newWidth; x++)
            for (int y = 0; y < newHeight; y++)
                scaledTexture.SetPixel(x, y, source.GetPixel(Mathf.FloorToInt(x / scaleFactor), Mathf.FloorToInt(y / scaleFactor)));

        scaledTexture.filterMode = FilterMode.Point;
        scaledTexture.Apply();

        return scaledTexture;
    }
    public static Texture2D EmptyTexture(this Texture originalTexture)
    {
        if (originalTexture == null || !(originalTexture is Texture2D)) return null;

        Texture2D originalTexture2D = (Texture2D)originalTexture;
        Texture2D emptyTexture = new Texture2D(originalTexture2D.width, originalTexture2D.height);
        emptyTexture.SetPixels(new Color[emptyTexture.width * emptyTexture.height]);
        emptyTexture.filterMode = FilterMode.Point;
        emptyTexture.Apply();

        return emptyTexture;
    }
    public static Texture2D Readable(this Texture2D source)
    {
        RenderTexture renderTex = RenderTexture.GetTemporary(
                    source.width,
                    source.height,
                    0,
                    RenderTextureFormat.Default,
                    RenderTextureReadWrite.Linear);

        Graphics.Blit(source, renderTex);
        RenderTexture previous = RenderTexture.active;
        RenderTexture.active = renderTex;
        Texture2D readableText = new Texture2D(source.width, source.height);
        readableText.ReadPixels(new Rect(0, 0, renderTex.width, renderTex.height), 0, 0);
        readableText.Apply();
        RenderTexture.active = previous;
        RenderTexture.ReleaseTemporary(renderTex);
        return readableText;
    }

    public static Sprite ApplyColorizeEffect(this Sprite sprite, Color targetColor, float factor = 1.0f)
    {
        var tex = sprite.texture;
        var newTex = new Texture2D(tex.width, tex.height, tex.format, tex.mipmapCount > 1);
        var pixels = tex.GetPixels();

        for (int i = 0; i < pixels.Length; i++)
        {
            float r = Mathf.Lerp(pixels[i].r, targetColor.r, factor);
            float g = Mathf.Lerp(pixels[i].g, targetColor.g, factor);
            float b = Mathf.Lerp(pixels[i].b, targetColor.b, factor);

            pixels[i] = new Color(r, g, b, pixels[i].a);
        }

        newTex.filterMode = FilterMode.Point;
        newTex.SetPixels(pixels);
        newTex.Apply();
        return Sprite.Create(newTex, sprite.rect, sprite.pivot / sprite.rect.size, sprite.pixelsPerUnit);
    }

    public static Sprite LoadSprite(string path, bool withoutIncludeModPath = false, FilterMode filterMode = FilterMode.Point, float pixels = 35) => Utils.LoadSprite((withoutIncludeModPath == true ? path : modPath + "\\" + path), filterMode, pixels, false);
    public static Sprite GetSlicedSprite(this Texture2D texture, Rect rect, float pixelsPerUnit = 35)
    {
        Texture2D clonedTexture = new Texture2D(Mathf.FloorToInt(rect.width), Mathf.FloorToInt(rect.height), texture.format, texture.mipmapCount > 1);

        Color[] pixels = texture.GetPixels(
            Mathf.FloorToInt(rect.x),
            Mathf.FloorToInt(rect.y),
            Mathf.FloorToInt(rect.width),
            Mathf.FloorToInt(rect.height)
        );

        clonedTexture.filterMode = FilterMode.Point;
        clonedTexture.SetPixels(pixels);
        clonedTexture.Apply();

        return Sprite.Create(clonedTexture, new Rect(0, 0, rect.width, rect.height), Vector2.one * 0.5f, pixelsPerUnit);
    }

    public static Texture2D LoadTexture(string path) => Utils.LoadTexture(modPath + "\\" + path);
    public static AudioClip LoadSound(string path) => Utils.FileToAudioClip(modPath + "\\" + path);

    public static bool NoWrong(LimbBehaviour limb)
    {
        try
        {
            limb.ManagedFixedUpdate();
            limb.ManagedLateUpdate();
            limb.ManagedUpdate();
        }
        catch
        {
            return false;
        }
        return true;
    }

    public static void FixKnockout()
    {
        LimbBehaviourManager Manager = UnityEngine.Object.FindObjectOfType<LimbBehaviourManager>();
        for (int i = 0; i < LimbBehaviourManager.Limbs.Count; i++)
        {
            try
            {
                LimbBehaviourManager.Limbs[i].ManagedFixedUpdate();
                LimbBehaviourManager.Limbs[i].ManagedLateUpdate();
                LimbBehaviourManager.Limbs[i].ManagedUpdate();
            }
            catch
            {
                LimbBehaviourManager.Limbs.RemoveAt(i);
                i--;
            }
        }
    }

    internal static void DisintegrationEffect(Vector3 Pos, Color color, float speed)
    {
        GameObject DisintegrationObject = ModAPI.CreateParticleEffect("Disintegration", Pos);
        foreach (AudioSource AudioSource in DisintegrationObject.GetComponents<AudioSource>())
            UnityEngine.Object.Destroy(AudioSource);
        foreach (ParticleSystem ParticleSystem in DisintegrationObject.GetComponentsInChildren<ParticleSystem>())
        {
            var Main = ParticleSystem.main;
            Main.simulationSpeed *= speed;
            Main.startColor = color;
        }
    }

    internal static void Integrate(this PhysicalBehaviour phys)
    {
        phys.gameObject.isStatic = false;
        phys.gameObject.ForEach<Collider2D>(col => phys.transform.root.gameObject.ForEach<Collider2D>(col2 => { col.enabled = true; Physics2D.IgnoreCollision(col, col2); }));
        phys.gameObject.ForEach<Renderer>(renderer => renderer.enabled = true);
        phys.gameObject.ForEach<Rigidbody2D>(rigidbody => rigidbody.simulated = true);
        if (phys.TryGetComponent(out BloodTankBehaviour component))
            component.enabled = true;
        phys.gameObject.SetActive(true);
        phys.isDisintegrated = false;
    }

    internal static GameObject CreateVaporiseEffect(Vector3 pos, (Bounds? _bounds, float? scale)? info = null, GameObject propEffect = null, Rigidbody2D rigid = null)
    {
        float scale = info?.scale ?? 1f;
        var bounds = info?._bounds ?? new Bounds(pos, new Vector3(1.2f, 1.2f, 0.2f) * scale);
        var Effect = UnityEngine.Object.Instantiate(propEffect ?? Resources.Load<GameObject>("Prefabs/VaporiseEffect"), pos, Quaternion.identity);
        float num = Mathf.Clamp(10 * Mathf.Sqrt(bounds.extents.sqrMagnitude * 4f), 2f, 250f);
        if (Effect.TryGetComponent(out ParticleSystem particleSystem))
        {
            for (int num2 = 0; num2 < num; num2++)
            {
                var randomPos = new Vector3(UnityEngine.Random.Range(bounds.min.x, bounds.max.x), UnityEngine.Random.Range(bounds.min.y, bounds.max.y), 0);
                particleSystem.Emit(new ParticleSystem.EmitParams
                {
                    position = randomPos,
                    velocity = 2f * UnityEngine.Random.value * (rigid != null ? rigid.GetPointVelocity(randomPos) : Vector2.zero)
                }, 1);
            }
            Invoker.StartCoroutine(DestroyTask(Effect, () => particleSystem.isStopped));
        }
        return Effect;
    }

    internal static void UltimateVaporise(this PhysicalBehaviour phys, bool wait = false)
    {
        if (wait)
        {
            NextFrameCoroutine(() => phys.UltimateVaporise());
            return;
        }
        CreateVaporiseEffect(phys.transform.position, (phys.spriteRenderer.bounds, 1f), null, phys.rigidbody);
        phys.UltimateDisintegrate();
    }

    internal static void UltimateDisintegrate(this PhysicalBehaviour phys, bool wait = false)
    {
        if (wait)
        {
            NextFrameCoroutine(() => phys.UltimateDisintegrate());
            return;
        }
        phys.Deletable = true;
        phys.Disintegratable = true;
        phys.Disintegrate();
    }

    internal static LimbBehaviour GetNearestLimb(this Vector2 vector, PersonBehaviour exclude = null)
    {
        float ClosestDest = Mathf.Infinity;
        LimbBehaviour Target = null;
        foreach (LimbBehaviour targets in LimbBehaviourManager.Limbs)
        {
            if (targets.isActiveAndEnabled && targets.gameObject.activeSelf && targets.HasBrain && targets.IsConsideredAlive && targets.Person && targets.Person.IsAlive() && targets.Person != exclude)
            {
                float distanceToEnemy = (targets.transform.position - (Vector3)vector).sqrMagnitude;
                if (distanceToEnemy < ClosestDest)
                {
                    ClosestDest = distanceToEnemy;
                    Target = targets;
                }
            }
        }
        return Target;
    }

    internal static List<Vector2> GetColliderGridPoints(this GameObject gameObject)
    {
        List<Vector2> list = new List<Vector2>();
        Collider2D[] colliders = gameObject.GetComponents<Collider2D>().Where(c => !c.isTrigger).ToArray();

        var bounds = new Bounds(gameObject.transform.position, Vector3.zero);
        foreach (var col in colliders)
            bounds.Encapsulate(col.bounds);
        bounds.size *= 0.999f;

        int gridSize = Mathf.Max(1, 4);
        Vector2 gridSpacing = bounds.size / gridSize;
        Vector2 gridMin = bounds.min;
        bool IsInsideOf(Collider2D[] colls, Vector2 globalPoint) => colls.Any(c => c.OverlapPoint(globalPoint));

        for (int j = 0; j <= gridSize; j++)
            for (int k = 0; k <= gridSize; k++)
            {
                Vector2 pos = gridMin + new Vector2(k * gridSpacing.x, j * gridSpacing.y);
                if (list.All(p => Vector2.Distance(p, pos) >= 0.025f) && IsInsideOf(colliders, pos))
                    list.Add(gameObject.transform.InverseTransformPoint(pos));
            }

        foreach (var col in colliders)
        {
            if (col is PolygonCollider2D poly)
                list.AddRange(poly.points.Select(p => p + poly.offset));
            else if (col is BoxCollider2D box)
            {
                Vector2 halfSize = box.size / 2f;
                list.AddRange(new[] { new Vector2(halfSize.x, halfSize.y), new Vector2(-halfSize.x, halfSize.y), new Vector2(-halfSize.x, -halfSize.y), new Vector2(halfSize.x, -halfSize.y) }.Select(p => p + box.offset));
            }
            else if (col is CircleCollider2D circle)
            {
                int points = Mathf.Clamp(Mathf.CeilToInt(6.2831855f * circle.radius / 0.25f), 6, 32);
                list.AddRange(Enumerable.Range(0, points).Select(i => new Vector2(Mathf.Cos(6.2831855f * i / points), Mathf.Sin(6.2831855f * i / points)) * circle.radius + circle.offset));
            }
        }

        return list;
    }

    internal static bool BeingHeldByGripper(this PhysicalBehaviour phys) => UnityEngine.Object.FindObjectsOfType<GripBehaviour>().FirstOrDefault(x => x.CurrentlyHolding == phys) != null;

    internal static void AdvancedSpriteChange(this SpriteRenderer spriteRenderer, Sprite sprite, bool refresh = true, bool fixColliders = true)
    {
        spriteRenderer.sprite = sprite;
        if (spriteRenderer.transform.parent && spriteRenderer.transform.parent.TryGetComponent(out SpriteRenderer Pspriterender))
        {
            spriteRenderer.sortingLayerName = Pspriterender.sortingLayerName;
            spriteRenderer.sortingOrder = Pspriterender.sortingOrder + 1;
        }
        if (fixColliders) spriteRenderer.gameObject.FixColliders();
        if (spriteRenderer.TryGetComponent(out PhysicalBehaviour Phys))
        {
            Phys.RecalculateMassBasedOnSize();
            if (refresh) Phys.RefreshOutline();
        }
    }

    internal static void AdvancedSpriteChange(this GameObject Instance, Sprite Sprite, bool Refresh = false, bool Fixcoll = true)
    {
        SpriteRenderer spriterender = Instance.GetComponent<SpriteRenderer>();
        spriterender.sprite = Sprite;
        if (Instance.transform.parent && Instance.transform.parent.TryGetComponent(out SpriteRenderer Pspriterender))
        {
            spriterender.sortingLayerName = Pspriterender.sortingLayerName;
            spriterender.sortingOrder = Pspriterender.sortingOrder + 1;
        }
        if (Refresh) Instance.GetComponent<PhysicalBehaviour>().RefreshOutline();
        if (Fixcoll) Instance.FixColliders();
    }

    public static void ChangeSpecificLimbSprite(this LimbBehaviour limbBehaviour, Sprite skin, Texture2D flash, Texture2D bone, Texture2D damage)
    {
        var limbSpriteRenderer = limbBehaviour.GetComponent<SpriteRenderer>();
        limbSpriteRenderer.sprite = skin;
        limbSpriteRenderer.material.SetTexture("_FleshTex", flash);
        limbSpriteRenderer.material.SetTexture("_BoneTex", bone);
        limbSpriteRenderer.material.SetTexture("_DamageTex", damage);
    }
    public static void ChangeSpecificLimbSprite(this SpriteRenderer spriteRenderer, Sprite skin, Texture2D flash, Texture2D bone, Texture2D damage, (bool flashEnabled, bool boneEnabled, bool damageEnabled) textureEnabled)
    {
        spriteRenderer.sprite = skin;
        spriteRenderer.material.SetTexture("_FleshTex", textureEnabled.flashEnabled ? flash : flash.EmptyTexture());
        spriteRenderer.material.SetTexture("_BoneTex", textureEnabled.boneEnabled ? bone : bone.EmptyTexture());
        spriteRenderer.material.SetTexture("_DamageTex", textureEnabled.damageEnabled ? damage : damage.EmptyTexture());
    }

    public static Material DeepCloneMaterial(this Material originalMaterial)
    {
        Material newMaterial = new Material(originalMaterial.shader);
        newMaterial.CopyPropertiesFromMaterial(originalMaterial);
        return newMaterial;
    }

    public class MaterialPropertiesMenu : MonoBehaviour
    {
        private int currentPage = 0, propertiesPerPage = 5;
        public static MaterialPropertiesMenu MaterialMenu { get; private set; }
        private void Awake()
        {
            MaterialMenu = this;
            DontDestroyOnLoad(gameObject);
        }

        public void ShowHierarchySpriteRenderers(GameObject rootObject)
        {
            var spriteRenderers = new List<(string path, SpriteRenderer sr)>();
            void CollectSpriteRenderers(GameObject obj, string path)
            {
                var sr = obj.GetComponent<SpriteRenderer>();
                if (sr != null && sr.material != null)
                    spriteRenderers.Add((string.IsNullOrEmpty(path) ? obj.name : $"{path}/{obj.name}", sr));
                foreach (Transform child in obj.transform)
                    CollectSpriteRenderers(child.gameObject, string.IsNullOrEmpty(path) ? obj.name : $"{path}/{obj.name}");
            }
            CollectSpriteRenderers(rootObject, "");
            if (spriteRenderers.Count == 0)
            {
                DialogBoxManager.Dialog("Sprite Renderer Properties",
                    new DialogButton("No SpriteRenderers found", false),
                    new DialogButton("Close", true, () => currentPage = 0));
                return;
            }
            int totalPages = (spriteRenderers.Count + propertiesPerPage - 1) / propertiesPerPage;
            var buttons = new List<DialogButton>();
            int start = currentPage * propertiesPerPage, end = Math.Min(start + propertiesPerPage, spriteRenderers.Count);
            for (int i = start; i < end; i++)
            {
                var (p, sr) = spriteRenderers[i];
                buttons.Add(new DialogButton($"{p}", true, () => ShowMaterialPropertiesMenu(sr.material, rootObject)));
            }
            if (currentPage > 0)
                buttons.Add(new DialogButton("Previous", true, () => { currentPage--; ShowHierarchySpriteRenderers(rootObject); }));
            if (currentPage < totalPages - 1)
                buttons.Add(new DialogButton("Next", true, () => { currentPage++; ShowHierarchySpriteRenderers(rootObject); }));
            buttons.Add(new DialogButton("Close", true, () => currentPage = 0));

            // 创建对话框并确保按钮纵向排列
            var dialog = DialogBoxManager.Dialog($"Sprite Renderers in {rootObject.name}", buttons.ToArray());

            var layout = dialog.DialogButtonHolder.gameObject;
            if (layout.TryGetComponent(out HorizontalLayoutGroup hlg)) UnityEngine.Object.DestroyImmediate(hlg);
            if (layout.TryGetComponent(out VerticalLayoutGroup vlg)) UnityEngine.Object.DestroyImmediate(vlg);
            GridLayoutGroup grid = layout.AddComponent<GridLayoutGroup>();
            grid.cellSize = new Vector2(150, 150);
            grid.spacing = new Vector2(15, 15);
            grid.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
            grid.constraintCount = 3;
            int rows = Mathf.CeilToInt(buttons.Count / 3f);
            layout.GetComponent<LayoutElement>().preferredHeight = rows * 150 + (rows - 1) * 15;

        }

        public void ShowMaterialPropertiesMenu(Material material, GameObject root = null)
        {
            var properties = GetMaterialProperties(material);
            int totalPages = (properties.Count + propertiesPerPage - 1) / propertiesPerPage;
            var buttons = new List<DialogButton>();
            int start = currentPage * propertiesPerPage, end = Math.Min(start + propertiesPerPage, properties.Count);
            for (int i = start; i < end; i++)
            {
                var prop = properties[i];
                var formatName = FormatPropertyName(prop.name);
                string text = "";
                switch (prop.type)
                {
                    case ShaderPropertyType.Color:
                        {
                            string hex = ColorToHex(material.GetColor(prop.name));
                            text = $"{formatName} ({prop.type}): <b><color=#{hex}>VIEW</color></b>";
                            buttons.Add(new DialogButton(text, true, () => EditProperty(material, prop.name, prop.type)));
                            break;
                        }
                    case ShaderPropertyType.Texture:
                        text = $"{formatName} ({prop.type}): {prop.value}";
                        buttons.Add(new DialogButton(text, false));
                        break;
                    default:
                        text = $"{formatName} ({prop.type}): {prop.value}";
                        buttons.Add(new DialogButton(text, true, () => EditProperty(material, prop.name, prop.type)));
                        break;
                }
            }
            if (currentPage > 0)
                buttons.Add(new DialogButton("Previous", true, () => { currentPage--; ShowMaterialPropertiesMenu(material); }));
            if (currentPage < totalPages - 1)
                buttons.Add(new DialogButton("Next", true, () => { currentPage++; ShowMaterialPropertiesMenu(material); }));
            buttons.Add(new DialogButton("Close", true, () => { currentPage = 0; if (root) ShowHierarchySpriteRenderers(root); }));
            var dialog = DialogBoxManager.Dialog("Material Properties", buttons.ToArray());

            var layout = dialog.DialogButtonHolder.gameObject;
            if (layout.TryGetComponent(out HorizontalLayoutGroup hlg)) UnityEngine.Object.DestroyImmediate(hlg);
            if (layout.TryGetComponent(out VerticalLayoutGroup vlg)) UnityEngine.Object.DestroyImmediate(vlg);
            GridLayoutGroup grid = layout.AddComponent<GridLayoutGroup>();
            grid.cellSize = new Vector2(150, 150);
            grid.spacing = new Vector2(15, 15);
            grid.constraint = GridLayoutGroup.Constraint.FixedColumnCount;
            grid.constraintCount = 3;
            int rows = Mathf.CeilToInt(buttons.Count / 3f);
            layout.GetComponent<LayoutElement>().preferredHeight = rows * 150 + (rows - 1) * 15;

        }


        private string ColorToHex(Color c) => $"{(int)(c.r * 255):X2}{(int)(c.g * 255):X2}{(int)(c.b * 255):X2}";
        private void EditProperty(Material material, string propertyName, ShaderPropertyType propertyType)
        {
            string currentValue = "", formatName = FormatPropertyName(propertyName);
            switch (propertyType)
            {
                case ShaderPropertyType.Color:
                    currentValue = ColorToSimpleString(material.GetColor(propertyName));
                    break;
                case ShaderPropertyType.Vector:
                    currentValue = VectorToSimpleString(material.GetVector(propertyName));
                    break;
                case ShaderPropertyType.Float:
                case ShaderPropertyType.Range:
                    currentValue = material.GetFloat(propertyName).ToString();
                    break;
            }
            DialogBox dialog = null;
            dialog = DialogBoxManager.TextEntry($"Edit {formatName} ({propertyType})", currentValue,
                new DialogButton("OK", true, () =>
                {
                    if (!string.IsNullOrEmpty(dialog.InputField.text))
                    {
                        try
                        {
                            switch (propertyType)
                            {
                                case ShaderPropertyType.Color:
                                    Color newColor = ParseSimpleColor(dialog.InputField.text);
                                    material.SetColor(propertyName, newColor);
                                    break;
                                case ShaderPropertyType.Vector:
                                    Vector4 newVector = ParseSimpleVector(dialog.InputField.text);
                                    material.SetVector(propertyName, newVector);
                                    break;
                                case ShaderPropertyType.Float:
                                case ShaderPropertyType.Range:
                                    float newFloat = float.Parse(dialog.InputField.text);
                                    material.SetFloat(propertyName, newFloat);
                                    break;
                            }
                            ShowMaterialPropertiesMenu(material);
                        }
                        catch (Exception ex)
                        {
                            Debug.LogError($"Failed to set property {formatName}: {ex.Message}");
                        }
                    }
                }),
                new DialogButton("Cancel", true, () => ShowMaterialPropertiesMenu(material))
            );
            dialog.ShowTextBox = true;
        }

        private string ColorToSimpleString(Color c) => $"{c.r} {c.g} {c.b} {c.a}";
        private string VectorToSimpleString(Vector4 v) => $"{v.x} {v.y} {v.z} {v.w}";

        private Color ParseSimpleColor(string s)
        {
            var parts = s.Split(' ');
            if (parts.Length != 4)
                throw new FormatException("Color must have 4 values (r g b a) separated by spaces.");
            return new Color(float.Parse(parts[0].Trim()), float.Parse(parts[1].Trim()),
                             float.Parse(parts[2].Trim()), float.Parse(parts[3].Trim()));
        }

        private Vector4 ParseSimpleVector(string s)
        {
            var parts = s.Split(' ');
            if (parts.Length != 4)
                throw new FormatException("Vector must have 4 values (x y z w) separated by spaces.");
            return new Vector4(float.Parse(parts[0].Trim()), float.Parse(parts[1].Trim()),
                               float.Parse(parts[2].Trim()), float.Parse(parts[3].Trim()));
        }

        private string FormatPropertyName(string name)
        {
            if (string.IsNullOrEmpty(name))
                return "";
            name = name.TrimStart('_');
            if (name.Length == 0)
                return "";
            var sb = new StringBuilder();
            sb.Append(name[0]);
            for (int i = 1; i < name.Length; i++)
                sb.Append(char.IsUpper(name[i]) ? " " + char.ToLower(name[i]) : name[i].ToString());
            return sb.ToString();
        }

        public static List<(string name, ShaderPropertyType type, string value)> GetMaterialProperties(Material material)
        {
            var props = new List<(string, ShaderPropertyType, string)>();
            if (material == null) { props.Add(("Error", ShaderPropertyType.Float, "Material is null")); return props; }
            var shader = material.shader;
            if (shader == null) { props.Add(("Error", ShaderPropertyType.Float, "Shader is null")); return props; }
            int count = shader.GetPropertyCount();
            for (int i = 0; i < count; i++)
            {
                string n = shader.GetPropertyName(i);
                ShaderPropertyType t = shader.GetPropertyType(i);
                string val = "";
                switch (t)
                {
                    case ShaderPropertyType.Color:
                        val = material.GetColor(n).ToString();
                        break;
                    case ShaderPropertyType.Vector:
                        val = material.GetVector(n).ToString();
                        break;
                    case ShaderPropertyType.Float:
                    case ShaderPropertyType.Range:
                        val = material.GetFloat(n).ToString();
                        break;
                    case ShaderPropertyType.Texture:
                        var tex = material.GetTexture(n);
                        val = tex != null ? tex.name : "null";
                        break;
                    default:
                        val = "Unsupported type";
                        break;
                }
                props.Add((n, t, val));
            }
            return props;
        }
    }

    public static string GetMaterialPropertiesString(Material material)
    {
        if (material == null)
        {
            return "Material is null";
        }
        Shader shader = material.shader;
        if (shader == null)
        {
            return "Shader is null";
        }
        StringBuilder sb = new StringBuilder();
        sb.AppendLine($"Material: {material.name}");
        sb.AppendLine($"Shader: {shader.name}");

        int propertyCount = shader.GetPropertyCount();
        for (int i = 0; i < propertyCount; i++)
        {
            string propertyName = shader.GetPropertyName(i);
            ShaderPropertyType propertyType = shader.GetPropertyType(i);
            string valueStr = "";
            switch (propertyType)
            {
                case ShaderPropertyType.Color:
                    Color color = material.GetColor(propertyName);
                    valueStr = color.ToString();
                    break;
                case ShaderPropertyType.Vector:
                    Vector4 vector = material.GetVector(propertyName);
                    valueStr = vector.ToString();
                    break;
                case ShaderPropertyType.Float:
                case ShaderPropertyType.Range:
                    float floatValue = material.GetFloat(propertyName);
                    valueStr = floatValue.ToString();
                    break;
                case ShaderPropertyType.Texture:
                    Texture texture = material.GetTexture(propertyName);
                    valueStr = texture != null ? texture.name : "null";
                    break;
                default:
                    valueStr = "Unsupported type";
                    break;
            }
            sb.AppendLine($"{propertyName} ({propertyType}): {valueStr}");
        }
        return sb.ToString();
    }

    public static AudioSource CreateAudioSource(this GameObject gameObject, float minDistance = 5, float maxDistance = 30, bool add = true)
    {
        var audioSource = gameObject.AddComponent<AudioSource>();
        audioSource.spatialBlend = 1;
        audioSource.minDistance = minDistance;
        audioSource.maxDistance = maxDistance;
        if (add)
            Global.main.AddAudioSource(audioSource);
        return audioSource;
    }

    public static GameObject PlayClip(this AudioClip audioClip, Vector3 position, float volume, int scale, float deleteAfterSeconds = 10f, float min = 5, float max = 20, Transform followTo = null)
    {
        List<AudioSource> audioSources = new List<AudioSource>();
        var newObj = new GameObject("TempSource");
        newObj.transform.position = position;
        for (int i = 0; i < scale; i++)
        {
            var newSource = newObj.CreateAudioSource(min, max);
            newSource.volume = volume;
            newSource.clip = audioClip;
            Global.main.AddAudioSource(newSource);
            audioSources.Add(newSource);
        }
        audioSources.ForEach(x => x.Play());
        if (followTo != null)
        {
            var pc = newObj.AddComponent<PseudoChild>();
            pc.Parent = followTo;
            pc.ScaleSync = false;
            pc.RotationSync = false;
        }
        if (deleteAfterSeconds != -1)
            InvokeAfterDelay(deleteAfterSeconds, () => newObj.Destroy());
        return newObj;
    }

    public static void DoOnce(string nameOperation, Action action)
    {
        if (PlayerPrefs.GetInt(nameOperation, 0) == 0)
        {
            PlayerPrefs.SetInt(nameOperation, 1);
            action.Invoke();
        }
    }

    internal static void DestroyMult(this IEnumerable<UnityEngine.Object> Objs, bool Immediate = false) => Objs.ForEach(x =>
    {
        if (!Immediate)
            x?.Destroy();
        else
            x?.DestroyImmediate();
    });

    internal static void AddMultipleComponents(this GameObject Instance, params Type[] Types) => Types.ForEach(c =>
    {
        if (!Instance.GetComponent(c)) Instance.AddComponent(c);
    });

    internal static SpriteRenderer CreateSpriteObject(this Transform Parent, Vector3 LocalPosition, Vector3 LocalScale, Sprite Sprite, bool ShouldGlow = false, UnityAction<GameObject> Action = null)
    {
        GameObject SpriteObject = new GameObject($"SpriteObject_{Parent.name}_{UnityEngine.Random.Range(-99999, 99999)}", typeof(Optout));
        SpriteObject.transform.SetParent(Parent);
        SpriteObject.transform.localPosition = LocalPosition;
        SpriteObject.transform.rotation = SpriteObject.transform.parent.rotation;
        SpriteObject.transform.localScale = LocalScale;
        SpriteRenderer SpriteObjectRenderer = SpriteObject.GetOrAddComponent<SpriteRenderer>();
        if (Sprite != null)
            AdvancedSpriteChange(SpriteObjectRenderer, Sprite, false);
        if (ShouldGlow)
            SpriteObjectRenderer.sharedMaterial = ModAPI.FindMaterial("VeryBright");
        Action?.Invoke(SpriteObject);
        return SpriteObjectRenderer;
    }

    internal static SpriteRenderer CreateBurnableSpriteObject(this PhysicalBehaviour physicalBehaviour, Sprite Sprite, int order = -999)
    {
        var renderer = CreateSpriteObject(physicalBehaviour.transform, new Vector3(0, 0, 0), new Vector3(1, 1, 1), Sprite);
        renderer.gameObject.GetOrAddComponent<BurnableSpriteObject>().referencePhys = physicalBehaviour;
        if (order != -999)
            renderer.sortingOrder = order;
        return renderer;
    }

    internal static void ChangeLimbHealthBar(this LimbBehaviour Limb, UnityAction<GameObject> Action = null)
    {
        var LimbBar = (GameObject)typeof(LimbBehaviour).GetField("myStatus", BindingFlags.NonPublic | BindingFlags.Instance).GetValue(Limb);
        var Status = LimbBar.GetComponent<LimbStatusBehaviour>();
        Action?.Invoke(LimbBar);
    }

    internal static void CreateUseEventTrigger(this GameObject obj, Action action) => obj.AddComponent<UseEventTrigger>().Action = action;

    public static PhysicalBehaviour InitializePhysicalComponent(this GameObject gameObject)
    {
        gameObject.layer = LayerMask.NameToLayer("Objects");
        gameObject.GetOrAddComponent<Rigidbody2D>();
        gameObject.GetOrAddComponent<SpriteRenderer>();
        gameObject.GetOrAddComponent<BoxCollider2D>();
        var physicalBehaviour = gameObject.AddComponent<PhysicalBehaviour>();
        physicalBehaviour.Properties = ModAPI.FindPhysicalProperties("Metal");
        physicalBehaviour.SpawnSpawnParticles = false;
        gameObject.AddComponent<AudioSourceTimeScaleBehaviour>();
        physicalBehaviour.OverrideShotSounds = Array.Empty<AudioClip>();
        physicalBehaviour.OverrideImpactSounds = Array.Empty<AudioClip>();
        return physicalBehaviour;
    }

    internal static string GradientText(string text, Color[] colors, int offset = 0)
    {
        double sigma2 = 0.035, sqrt2PiSigma = Math.Sqrt(2.0 * Math.PI * sigma2);
        int numColors = colors.Length;
        return string.Concat(text.Select((c, i) =>
        {
            if (c == ' ') return " ";
            double x = (double)((i + offset) % text.Length) / text.Length, totalWeight = 0;
            var weightedSum = Color.black;
            Enumerable.Range(0, numColors).ForEach(j =>
            {
                double mu = (double)j / (numColors - 1), weight = Math.Exp(-(x - mu) * (x - mu) / (2.0 * sigma2)) / sqrt2PiSigma;
                totalWeight += weight;
                weightedSum += colors[j] * (float)weight;
            });
            return $"<color=#{ColorUtility.ToHtmlStringRGB(weightedSum / (float)totalWeight)}>{c}</color>";
        }));
    }


    public static IEnumerable<(GameObject gameObject, Vector2 pos, Vector2 dir)> CastRays(this (Vector2 origin, Vector2 direction) data, int rayCount = 16, float spreadAngle = 45f, float emitterSize = 0.5f, float range = 10f, params Transform[] except)
    {
        var buffer = new RaycastHit2D[1024];
        return Enumerable.Range(0, rayCount).SelectMany(i => {
            float n = (float)i / ((float)rayCount - 1f);
            Vector2 dir = Quaternion.Euler(0f, 0f, n * spreadAngle - spreadAngle / 2f) * data.direction;
            return buffer.Take(Physics2D.RaycastNonAlloc(data.origin + Vector2.Perpendicular(data.direction) * (n * emitterSize - emitterSize / 2f), dir, buffer, range, mask)).Select(hit => (hit.transform.gameObject, hit.point, dir));
        }).Where(hit => hit.gameObject.GetRoot() != null && (except?.Contains(hit.gameObject.GetRoot().transform) != true)).GroupBy(hit => hit.gameObject).Select(group => group.First());
    }

    public static Vector2 GetDirection(this Vector2 v, Vector2 other)
    {
        Vector2 direction = other - v;
        float x = direction.x == 0 ? 0 : direction.x / (Mathf.Abs(direction.x)), y = direction.y == 0 ? 0 : direction.y / (Mathf.Abs(direction.y));
        return new Vector2(x, y);
    }

    public static void CreateGlobalButton(string text, UnityAction action = null)
    {
        var contextMenu = (ContextMenuBehaviour)typeof(ContextMenuBehaviour).GetField("Instance", BindingFlags.NonPublic | BindingFlags.Static).GetValue(null);
        var newButton = GameObject.Instantiate(contextMenu.ButtonPrefab, contextMenu.ButtonParent);
        newButton.BetterDestroy<TextUpdaterBehaviour>();
        newButton.transform.GetChild(0).gameObject.GetComponent<TextMeshProUGUI>().text = text;
        newButton.GetComponent<Button>().onClick.AddListener(() =>
        {
            contextMenu.Hide();
            action?.Invoke();
        });
    }

    public static void SetSprite(this GameObject gameObject, Sprite sprite, bool fixColliders = true, string sortingLayerName = "Default", int sortingOrder = 4)
    {
        var renderer = gameObject.GetOrAddComponent<SpriteRenderer>();
        renderer.sprite = sprite;
        renderer.sortingLayerName = sortingLayerName;
        renderer.sortingOrder = sortingOrder;
        if (fixColliders)
            gameObject.FixColliders();
        if (gameObject.TryGetComponent(out PhysicalBehaviour physicalBehaviour))
            physicalBehaviour.RefreshOutline();
    }

    public static Texture2D FlipVertically(this Texture2D original)
    {
        int width = original.width, height = original.height;
        Texture2D m_texture = new Texture2D(width, height);
        for (int y = 0; y < height; y++)
        {
            Color[] row = original.GetPixels(0, y, width, 1);
            m_texture.SetPixels(0, height - 1 - y, width, 1, row);
        }
        m_texture.Apply();
        m_texture.filterMode = FilterMode.Point;
        return m_texture;
    }
    internal static void UltimateSlice(this GameObject target, bool Wait = false, bool sliceForever = false)
    {
        if (Wait)
        {
            NextFrameCoroutine(() => target.UltimateSlice());
            return;
        }
        target.UltimateBreak();
        DoOnce(target);
        void DoOnce(GameObject @object) => TryCatchAction(() =>
        {
            @object.transform.SendMessage("Slice", SendMessageOptions.DontRequireReceiver);
            if (@object.TryGetComponent(out LimbBehaviour limb))
            {
                limb.ImmuneToDamage = false;
                limb.BreakingThreshold = 0;
                limb.Slice();
            }
            @object.ForEach<Joint2D>(joint =>
            {
                @object.BroadcastMessage("OnJointBreak2D", joint);
                joint.DestroyImmediate();
            });
        });
        if (sliceForever && !sliceForeverList.Contains(target))
        {
            sliceForeverList.Add(target);
            Invoker.AddUpdateAction(() => DoOnce(target));
        }
    }

    internal static void UltimateBreak(this GameObject target, bool Wait = false, bool breakForever = false)
    {
        if (Wait)
        {
            NextFrameCoroutine(() => target.UltimateBreak());
            return;
        }
        DoOnce(target);
        void DoOnce(GameObject @object, bool checkMore = false) => TryCatchAction(() =>
        {
            if (@object.TryGetComponent(out DestroyableBehaviour destroyable))
            {
                destroyable.OverallChance = float.MaxValue;
                destroyable.Break();
            }

            if (@object.TryGetComponent(out DamagableMachineryBehaviour damagable))
            {
                damagable.Indestructible = false;
                damagable.BreakPermanently();
            }

            if (@object.TryGetComponent(out LimbBehaviour limb) && (!checkMore || !limb.Broken))
                typeof(LimbBehaviour).GetMethod("BreakBoneInternal", BindingFlags.NonPublic | BindingFlags.Instance).Invoke(limb, null);

            @object.transform.SendMessage("Break", SendMessageOptions.DontRequireReceiver);
            @object.transform.SendMessage("OnEMPHit", SendMessageOptions.DontRequireReceiver);
        });

        if (breakForever && !breakForeverList.Contains(target))
        {
            breakForeverList.Add(target);
            Invoker.AddUpdateAction(() => DoOnce(target, true));
        }
    }

    internal static void UltimateCrush(this LimbBehaviour limb, bool Wait = false)
    {
        if (Wait)
        {
            NextFrameCoroutine(() => limb.UltimateCrush());
            return;
        }
        TryCatchAction(() =>
        {
            limb.PhysicalBehaviour.Deletable = true;
            limb.PhysicalBehaviour.Disintegratable = true;
            limb.ImmuneToDamage = false;
            limb.Crush();
        });
    }

    internal static float TotalMass(this GameObject obj) => obj.transform.root.GetComponentsInChildren<Rigidbody2D>().Sum(r => r.mass);

    internal static void TryCatchAction(Action tryAction = null, Action catchAction = null)
    {
        try { tryAction?.Invoke(); }
        catch { catchAction?.Invoke(); }
    }

    internal static GameObject InstantiatePrefab(SpawnableAsset Substitute, Vector3 pos, Quaternion rot, UnityAction<GameObject> afterSpawn = null)
    {
        var SpawnObject = UnityEngine.Object.Instantiate(Substitute.Prefab, pos, rot);
        SpawnObject.AddComponent<AudioSourceTimeScaleBehaviour>();
        SpawnObject.transform.name = Substitute.name;
        SpawnObject.GetOrAddComponent<SerialiseInstructions>().OriginalSpawnableAsset = Substitute;
        CatalogBehaviour.PerformMod(Substitute, SpawnObject);
        afterSpawn?.Invoke(SpawnObject);
        return SpawnObject;
    }

    internal static GameObject CreateChildSprite(this Transform parent, string name, Sprite sprite, UnityAction<GameObject> Action = null)
    {
        var obj = new GameObject($"SpriteObject_{name}_{UnityEngine.Random.Range(-99999, 99999)}", typeof(Optout));
        obj.transform.SetParent(parent);
        obj.transform.localPosition = new Vector3(0, 0f);
        obj.transform.rotation = parent.rotation;
        obj.transform.localScale = new Vector3(1f, 1f);
        var obj_sprite = obj.AddComponent<SpriteRenderer>();
        obj_sprite.sprite = sprite;
        var m_sprite = parent.gameObject.GetComponent<SpriteRenderer>();
        obj_sprite.sortingLayerName = m_sprite.sortingLayerName;
        obj_sprite.sortingOrder = m_sprite.sortingOrder + 1;
        Action?.Invoke(obj);
        return obj;
    }

    internal static void CreatePulseExplosion(Vector3 position, float force, float range, (bool canBreak, bool canSlice) mode, float chance = 0.25f, params Transform[] except)
    {
        CameraShakeBehaviour.main.Shake(force * range * 2f, position, 1f);
        var hits = new Collider2D[256];
        hits.Take(Physics2D.OverlapCircleNonAlloc(position, range, hits, LayerMask.GetMask("Objects", "CollidingDebris", "Debris"))).Where(hit => !except.Contains(hit.transform.root))
            .ForEach(hit => {
                if (hit && hit.attachedRigidbody)
                {
                    var attachedRigidbody = hit.attachedRigidbody;
                    var a = hit.transform.position - position;
                    float sqrMagnitude = a.sqrMagnitude;
                    if (sqrMagnitude >= 1E-45f)
                    {
                        attachedRigidbody.AddForce((force / Mathf.Max(1f, sqrMagnitude / (range * range)) * 3f) * (a / Mathf.Sqrt(sqrMagnitude)) * Mathf.Min(attachedRigidbody.mass, 1f), ForceMode2D.Impulse);

                        if (UnityEngine.Random.value < chance && mode.canBreak)
                            hit.gameObject.UltimateBreak(true);

                        if (UnityEngine.Random.value < chance && !Helper.HasInstance(hit.transform.root.gameObject) && mode.canSlice)
                            hit.gameObject.UltimateSlice();
                    }
                }
            });
    }

    public static void CreateGravityPoint(this Vector3 point, (bool All, List<GameObject> Target) Settings, float attractionStrength, float dampingStrength, float stopDistance, float stopVelocity, float gravityCompensation)
    {
        if (GravityPoints.ContainsKey(point))
        {
            Invoker.RemoveFixedUpdateAction(GravityPoints[point]);
            GravityPoints.Remove(point);
        }
        GravityPoints[point] = () =>
        {
            if (!Settings.All)
                Settings.Target.RemoveAll(x => x == null);
            (Settings.All ? FindTypesInWorld<Rigidbody2D>().Where(x => x.gameObject.scene.IsValid()) : Settings.Target.SelectMany(x => x.GetComponentsInChildren<Rigidbody2D>())).Where(x => x.bodyType == RigidbodyType2D.Dynamic).ForEach(x =>
            {

                Vector2 direction = point - x.transform.position;
                float distance = direction.magnitude;

                Vector2 gravityForce = Physics2D.gravity * x.mass;

                if (distance > stopDistance || x.velocity.magnitude > stopVelocity)
                {
                    Vector2 attractionForce = direction.normalized * (attractionStrength * distance) * x.mass;
                    Vector2 dampingForce = -x.velocity * dampingStrength * x.mass;
                    Vector2 finalForce = attractionForce + dampingForce - gravityForce * gravityCompensation;
                    x.AddForce(finalForce);
                }
                else
                {
                    Vector2 attractionForce = direction.normalized * (attractionStrength * distance) * x.mass;
                    Vector2 finalForce = attractionForce - gravityForce * gravityCompensation;
                    x.AddForce(finalForce);
                }

            });
        };
        Invoker.AddFixedUpdateAction(GravityPoints[point]);
    }

    public static void RemoveGravityPoint(this Vector3 point)
    {
        if (!GravityPoints.ContainsKey(point))
            return;
        Invoker.RemoveFixedUpdateAction(GravityPoints[point]);
        GravityPoints.Remove(point);
    }

    public static void CreateSmoke(Transform parent, Vector3 pos, float life) => Global.main.StartCoroutine(CreateSmokeCor(parent, pos, life));

    public static GameObject CreateExSmoke(Vector3 pos, Color color, float speed = 1f, bool HasSource = false, UnityAction<GameObject> Action = null)
    {
        var Explosion = UnityEngine.Object.Instantiate<GameObject>(Resources.Load<GameObject>("Prefabs/Explosion"), pos, Quaternion.identity);
        Explosion.ForEach<ParticleSystem>(ExplosionParticle => { var main = ExplosionParticle.main; main.startColor = color; main.simulationSpeed *= speed; });
        if (!HasSource)
        {
            Explosion.GetComponentsInChildren<AudioBehaviour>().DestroyMult();
            Explosion.GetComponent<ExplosionSoundBehviour>().Destroy();
        }
        Explosion.transform.Find("Fire").gameObject.SetActive(false);
        Explosion.transform.Find("Flash").gameObject.SetActive(false);
        Explosion.transform.Find("Embers (1)").gameObject.SetActive(false);
        Invoker.StartCoroutine(DestroyTask(Explosion, () => Explosion.GetComponent<ParticleSystem>().isStopped));
        Action?.Invoke(Explosion);
        return Explosion;
    }

    internal static IEnumerator CreateSmokeCor(Transform parent, Vector3 pos, float life)
    {
        var smoke = UnityEngine.Object.Instantiate<GameObject>(smokePrefab);
        smoke.transform.position = pos;
        var pseudoChild = smoke.AddComponent<PseudoChild>();
        pseudoChild.ScaleSync = false;
        pseudoChild.RotationSync = false;
        if (parent != null) pseudoChild.Parent = parent;
        pseudoChild.DeleteAfterParentDestroy = 0;
        var ps = smoke.GetComponent<ParticleSystem>();
        var main = ps.main;
        var emession = ps.emission;
        var shape = ps.shape;
        main.maxParticles = 5000;
        emession.rateOverDistanceMultiplier = 250f;
        shape.radius = 1;
        shape.angle = 90;
        shape.arc = 1;
        shape.randomDirectionAmount = 1f;
        shape.radiusSpeedMultiplier = 1;
        main.simulationSpeed = 20;
        main.simulationSpace = ParticleSystemSimulationSpace.Custom;
        ps.Play();
        yield return new WaitForSeconds(life);
        ps.Stop();
        yield return new WaitForSeconds(life);
        smoke.Destroy();
    }

    public static void CreateLightningBolt(Vector3 startPos, Vector3 endPos, Color color, float width = 0.04f, float life = 0.1f) => Global.main.StartCoroutine(CreateLightningBoltCor(startPos, endPos, color, width, life));

    public static IEnumerator CreateLightningBoltCor(Vector3 startPos, Vector3 endPos, Color color, float width = 0.04f, float life = 0.1f)
    {
        var Lightning = UnityEngine.Object.Instantiate(UnityEngine.Object.FindObjectOfType<WeatherLightningBehaviour>());
        var SingleBolt = Lightning.LineRenderer;
        var vertices = new Vector3[SingleBolt.positionCount];
        SingleBolt.startColor = color;
        SingleBolt.endColor = color;
        SingleBolt.widthCurve = new AnimationCurve(new Keyframe(0f, width), new Keyframe(0.5f, width * 1.6f), new Keyframe(1f, width * 0.02f));
        Lightning.LightSprite.transform.position = startPos;
        float x = UnityEngine.Random.value * 10000f, num = Vector2.Distance(startPos, endPos) * 0.05f;
        Lightning.AudioSource.PlayOneShot(Lightning.Thunder.PickRandom<AudioClip>());
        int num2 = vertices.Length;
        //SingleBolt.startWidth = width;
        //SingleBolt.endWidth = width;
        SingleBolt.enabled = true;
        Lightning.LightSprite.enabled = true;
        float time = 0f;
        while (time < life)
        {
            for (int j = 0; j < num2; j++)
            {
                float num3 = (float)j / (float)num2;
                float d = 1f - Mathf.Abs(2f * num3 - 1f);
                Vector3 a = (Utils.GetPerlin2Mapped(x, num3 / num * 19f) + (Vector3)(UnityEngine.Random.insideUnitCircle * 0.2f)) * d;
                vertices[j] = Vector3.Lerp(startPos, endPos, num3) + num * a;
            }
            SingleBolt.SetPositions(vertices);
            CameraShakeBehaviour.main.Shake(150f, endPos, 0.1f);
            time += Time.deltaTime;
            yield return new WaitForFixedUpdate();
        }
        SingleBolt.enabled = false;
        Lightning.LightSprite.enabled = false;
        while (Lightning.AudioSource.isPlaying)
            yield return null;
        Lightning.gameObject.Destroy();
    }

    public static (GameObject main, (LineRenderer line_white, LineRenderer line_black) line, Vector3 startPos, Vector3 endPos, Vector3 midPos) SliceEffect(Vector3 startPos, Vector3 endPos, Color outside, Color inside, int midPointsCount = 1, float width = 0.125f, int type = 1, float wait = 1f, float maxTime = 1f, float speed = 1f)
    {
        var lineParent = new GameObject("Line");

        var line_white = CreateLineRenderer(lineParent, "LineWhite", ModAPI.FindMaterial("VeryBright"), outside, new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, width), new Keyframe(1f, 0f)));
        var line_black = CreateLineRenderer(lineParent, "LineBlack", null, inside, null, line_white);

        var positions = new Vector3[midPointsCount + 2];
        positions[0] = startPos;
        positions[positions.Length - 1] = endPos;

        for (int i = 1; i <= midPointsCount; i++)
        {
            float t = (float)i / (midPointsCount + 1);
            positions[i] = Vector3.Lerp(startPos, endPos, t);
        }

        line_white.SetPositions(positions);
        line_black.SetPositions(positions);

        var midP = positions.Skip(1).Take(midPointsCount);
        var midPos = midP.Aggregate(Vector3.zero, (acc, pos) => acc + pos) / midP.Count();
        Vector3 dir = (endPos - startPos).normalized * 20 * width;
        Global.main.StartCoroutine(Destroy());
        IEnumerator Destroy()
        {
            yield return new WaitForSeconds(wait);
            float time = 0f;
            while (time < maxTime)
            {
                float t = Mathf.Pow(time, 3);
                for (int i = 0; i < positions.Length; i++)
                    positions[i] = Vector3.Lerp(positions[i], (type == 1 ? midPos : (type == 2 ? endPos + dir : startPos - dir)), t);
                line_white.SetPositions(positions);
                line_black.SetPositions(positions);
                time += Time.deltaTime * speed;
                yield return new WaitForEndOfFrame();
            }
            lineParent.DestroyImmediate();
        }

        LineRenderer CreateLineRenderer(GameObject parent, string name, Material material = null, Color color = default, AnimationCurve widthCurve = null, LineRenderer prev = null)
        {
            var lineGO = new GameObject(name);
            lineGO.transform.SetParent(parent.transform);
            var line = lineGO.AddComponent<LineRenderer>();
            line.material = material ?? ModAPI.FindMaterial("Sprites-Default");
            line.positionCount = midPointsCount + 2;
            line.startColor = line.endColor = color;
            line.widthCurve = widthCurve ?? new AnimationCurve(new Keyframe(0f, 0f), new Keyframe(0.5f, width * 0.6f), new Keyframe(1f, 0f));
            if (prev != null)
            {
                line.sortingLayerName = prev.sortingLayerName;
                line.sortingOrder = prev.sortingOrder + 1;
            }
            return line;
        }
        return (lineParent, (line_white, line_black), startPos, endPos, midPos);
    }

    public static void ClearEverything(params GameObject[] expect)
    {
        EnvironmentalSettings settings = null;
        if ((bool)MapConfig.Instance)
        {
            settings = MapConfig.Instance.Settings.ShallowClone();
            MapLightBehaviour.StartEnabled = settings.Floodlights;
            PhysicalBehaviour.AmbientTemperature = settings.Ambient_temperature;
        }


        UnityEngine.Object.FindObjectsOfType<ObjectPoolBehaviour>().ForEach(x => x.Clear());

        UnityEngine.Object.FindObjectsOfType<GameObject>().ForEach(x =>
        {
            if (ToRemove.HasLayer(x.layer) && !expect.Contains(x))
                x.Destroy();
        });


        UnityEngine.Object.FindObjectsOfType<DecalControllerBehaviour>().ForEach(x => x.Clear());

        UndoControllerBehaviour.ClearHistory();
        if ((bool)AmbientTemperatureGridBehaviour.Instance)
            AmbientTemperatureGridBehaviour.Instance.World.Clear();

        UnityEngine.Object.FindObjectOfType<MapLoaderBehaviour>().Load();
        NextFrameCoroutine(() =>
        {
            if ((bool)MapConfig.Instance)
            {
                settings.CopyTo(MapConfig.Instance.Settings);
                MapConfig.Instance.ApplySettings(MapConfig.Instance.Settings);
            }

            if ((bool)EnvironmentSettingsController.Main)
                EnvironmentSettingsController.Main.Start();

            if ((bool)MapConfig.Instance)
            {
                UnityEngine.Object.FindObjectsOfType<MapLightBehaviour>().Where(x => x.enabled).ForEach(x =>
                {
                        if (MapConfig.Instance.Settings.Floodlights)
                            x.ActivateInstantly();
                        else
                            x.DeactivateInstantly();
                });
            }
        });
    }

    public static (Vector2 point, float distance) GetDistanceFromGround(this GameObject gameObject)
    {
        var transform = gameObject.transform;
        var hit = Physics2D.Raycast(transform.position, Vector2.down, Inf, LayerMask.GetMask("Objects", "Bounds"));
        if (hit && !ReferenceEquals(hit.collider.transform.root, transform.root))
            return (hit.point, hit.distance);
        return (default, float.PositiveInfinity);
    }

    public static (Vector2 point, float distance) GetDistanceFromGround(this Vector2 currentPosition, params Transform[] expectedRoot)
    {
        RaycastHit2D[] buffer = new RaycastHit2D[8];
        int hitCount = Physics2D.RaycastNonAlloc(currentPosition, Vector2.down, buffer, Inf, LayerMask.GetMask("Objects", "Bounds"));
        if (hitCount == 0)
            return (default, float.PositiveInfinity);
        var excludeRoots = expectedRoot?.Select(t => t.root).ToHashSet();
        for (int i = 0; i < hitCount; i++)
        {
            var hit = buffer[i];
            if (hit.collider == null)
                continue;
            var hitRoot = hit.collider.transform.root;
            if (excludeRoots == null || !excludeRoots.Contains(hitRoot))
                return (hit.point, hit.distance);
        }
        return (default, float.PositiveInfinity);
    }

    public static Vector2 BezierCurve(float t, Vector2 pointA, Vector2 pointB, Vector2 handleA, Vector2 handleB) => Mathf.Pow((1 - t), 3) * pointA + 3 * Mathf.Pow((1 - t), 2) * t * handleA + 3 * (1 - t) * Mathf.Pow(t, 2) * handleB + Mathf.Pow(t, 3) * pointB;

    public static void CreateFolder(string path) => Type.GetType("System.IO.Directory").GetMethods().FirstOrDefault(method => method.Name == "CreateDirectory").Invoke(null, new[] { path });

    internal static NoCollide NoCollideAtoB(GameObject A, GameObject B)
    {
        var NoCollide = B.AddComponent<NoCollide>();
        NoCollide.NoCollideSetA = A.GetComponentsInChildren<Collider2D>();
        NoCollide.NoCollideSetB = B.GetComponentsInChildren<Collider2D>();
        return NoCollide;
    }

    internal static void IgnoreCollision(IEnumerable<Collider2D> A, IEnumerable<Collider2D> B, bool ignore = true) => A.ForEach(a => B.Where(b => b != a).ForEach(b => Physics2D.IgnoreCollision(a, b, ignore)));

    internal static void CreateAudioWhenUse(this GameObject obj, Func<bool> condition, AudioClip[] Clip)
    {
        var source = obj.AddComponent<AudioSource>();
        source.spread = 100f;
        source.volume = 8f;
        source.minDistance = 18f;
        source.spatialBlend = 1f;
        source.dopplerLevel = 0f;
        Global.main.AddAudioSource(source);
        obj.AddComponent<UseEventTrigger>().Action = () =>
        {
            if (condition())
                source.PlayOneShot(Clip.PickRandom());
        };
    }

    internal static void MakePhysSharp(this PhysicalBehaviour Phys, SharpAxis SharpAxis)
    {
        PhysicalProperties Prop = UnityEngine.Object.Instantiate(Phys.Properties);
        Prop.Sharp = true;
        Prop.SharpAxes = new[] { SharpAxis };
        Phys.Properties = Prop;
    }

    internal static GameObject CreateGhost(Vector3 pos, Quaternion rot, Vector3 localScale, Sprite m_sprite, Color color, int sortingLayerID = default, float time = 10f, UnityAction<GameObject> action = null)
    {
        var ghost = new GameObject($"GhostObject_{UnityEngine.Random.Range(-99999, 99999)}");
        ghost.transform.position = pos;
        ghost.transform.rotation = rot;
        ghost.transform.localScale = localScale;
        var spriteRenderer = ghost.AddComponent<SpriteRenderer>();
        spriteRenderer.sprite = m_sprite;
        if (sortingLayerID != default)
            spriteRenderer.sortingLayerID = sortingLayerID;
        spriteRenderer.color = color;
        Global.main.StartCoroutine(ColorFade(spriteRenderer, time));
        IEnumerator ColorFade(SpriteRenderer render, float Delta)
        {
            var FinalColor = new Color(render.color.r, render.color.g, render.color.b, 0f);
            while (render.gameObject.activeInHierarchy && render.color != FinalColor)
            {
                render.color = Color.Lerp(render.color, FinalColor, Time.deltaTime * Delta);
                yield return new WaitForEndOfFrame();
            }
            UnityEngine.Object.Destroy(render.gameObject);
            yield return new WaitForEndOfFrame();
        }
        action?.Invoke(ghost);
        return ghost;
    }

    internal static Dont OnlyOneTimeAction(this GameObject gameObject, UnityAction Action)
    {
        if (!gameObject.GetComponent<Dont>()) Action.Invoke();
        return gameObject.GetOrAddComponent<Dont>();
    }

    public static void InvokeOnStart(this GameObject gameObject, Action action) => gameObject.AddComponent<InvokerOnStart>().ActionForInvoke = action;

    public static void InvokeOnObject<T>(this T @object, Action<T> action) where T : UnityEngine.Object => action.Invoke(@object);


    public static void InvokeAfterDelay(float delay, Action action)
    {
        Invoker.StartCoroutine(Task());
        IEnumerator Task()
        {
            yield return new WaitForSeconds(delay);
            action.Invoke();
        }
    }

    public class NewFreezeBehaviour : MonoBehaviour
    {
        private Rigidbody2D rb;

        private Vector2 velocity;
        private float angularVelocity;

        private void Awake()
        {
            rb = GetComponent<Rigidbody2D>();
            velocity = rb.velocity;
            angularVelocity = rb.angularVelocity;
            rb.bodyType = RigidbodyType2D.Static;
        }

        private void Stop()
        {
            if ((bool)rb)
            {
                rb.bodyType = RigidbodyType2D.Dynamic;
                rb.velocity = velocity;
                rb.angularVelocity = angularVelocity;
                this.Destroy();
            }
        }

        private void OnDestroy() => OnDisable();
        private void OnDisable() => Stop();
    }
    public class PID
    {
        public float Kp, Ki, Kd;
        private float lastError;
        private float P, I, D;
        public PID() { Kp = 1f; Ki = 0; Kd = 0.2f; }
        public PID(float pFactor, float iFactor, float dFactor) { this.Kp = pFactor; this.Ki = iFactor; this.Kd = dFactor; }
        public float Update(float error, float dt)
        {
            P = error;
            I += error * dt;
            D = (error - lastError) / dt;
            lastError = error;
            float CO = P * Kp + I * Ki + D * Kd;
            return CO;
        }
    }
    public class StabberFixer : MonoBehaviour
    {
        public SharpAxis SharpAxis
        {
            set
            {
                needChangeSharpAxis = true;
                m_SharpAxis = value;
            }
        }
        private bool needChangeSharpAxis = false;
        private SharpAxis m_SharpAxis;
        private PhysicalBehaviour physicalBehaviour;
        public Action<BoxCollider2D> OnFixed;
        private void Start()
        {
            physicalBehaviour = gameObject.GetComponent<PhysicalBehaviour>();
            StartCoroutine(FixCor());
        }
        private IEnumerator FixCor()
        {
            yield return new WaitForEndOfFrame();
            if (needChangeSharpAxis)
            {
                var newProperties = Instantiate(physicalBehaviour.Properties);
                newProperties.name += "Changed";
                newProperties.Sharp = true;
                newProperties.SharpAxes = new SharpAxis[] { m_SharpAxis };
                physicalBehaviour.Properties = newProperties;
            }
            gameObject.GetComponents<Collider2D>().ForEach(c => c.Destroy());
            var boxCollider = gameObject.AddComponent<BoxCollider2D>();
            yield return new WaitForEndOfFrame();
            physicalBehaviour.ResetColliderArray();
            yield return new WaitForEndOfFrame();
            physicalBehaviour.BakeColliderGridPoints();
            OnFixed?.Invoke(boxCollider);
        }
    }


    public static void CreateWhiteOverlay(float duration = 1f, bool glint = true)
    {
        GameObject canvasObj = new GameObject("WhiteOverlayCanvas");
        var whiteCanvas = canvasObj.AddComponent<Canvas>();
        canvasObj.AddComponent<CanvasScaler>();
        canvasObj.AddComponent<GraphicRaycaster>();

        whiteCanvas.renderMode = RenderMode.ScreenSpaceOverlay;
        whiteCanvas.sortingOrder = 9999;

        GameObject imageObj = new GameObject("WhiteOverlayImage");
        imageObj.transform.SetParent(canvasObj.transform);
        var whiteImage = imageObj.AddComponent<Image>();
        whiteImage.color = new Color(1, 1, 1, 1);

        RectTransform rectTransform = whiteImage.GetComponent<RectTransform>();
        rectTransform.anchorMin = Vector2.zero;
        rectTransform.anchorMax = Vector2.one;
        rectTransform.offsetMin = Vector2.zero;
        rectTransform.offsetMax = Vector2.zero;

        Global.main.StartCoroutine(FadeOutWhiteOverlay(true));

        IEnumerator FadeOutWhiteOverlay(bool easeIn)
        {
            if (glint)
                yield return new WaitForSeconds(Mathf.Min(0.1f, duration));

            float elapsed = 0.0f;
            while (elapsed < duration)
            {
                elapsed += Time.deltaTime;
                float t = elapsed / duration;
                t = easeIn ? t * t : 1 - (1 - t) * (1 - t); // 先慢后快（easeIn）或先快后慢
                whiteImage.color = new Color(1, 1, 1, 1 - t);
                yield return null;
            }

            whiteImage.color = new Color(1, 1, 1, 0);
            Destroy(whiteCanvas.gameObject);
        }

    }

    public static void CreateOverlayWithSpriteMask(this GameObject targetObject, float duration = 1f, bool glint = true, Sprite customSprite = null)
    {
        GameObject canvasObj = new GameObject("MaskedOverlayCanvas");
        var whiteCanvas = canvasObj.AddComponent<Canvas>();
        canvasObj.AddComponent<CanvasScaler>();
        canvasObj.AddComponent<GraphicRaycaster>();

        whiteCanvas.renderMode = RenderMode.ScreenSpaceOverlay;
        whiteCanvas.sortingOrder = -1;

        GameObject maskObj = new GameObject("OverlayMask");
        maskObj.transform.SetParent(targetObject.transform);
        maskObj.AddComponent<RectTransform>();
        var spriteMask = maskObj.AddComponent<SpriteMask>();

        if (targetObject.GetComponent<SpriteRenderer>() != null)
        {
            spriteMask.sprite = targetObject.GetComponent<SpriteRenderer>().sprite;
        }
        else if (customSprite != null)
        {
            spriteMask.sprite = customSprite;
        }
        else
        {
            Debug.LogError("No sprite found for mask!");
            return;
        }

        maskObj.GetComponent<RectTransform>().sizeDelta = new Vector2(spriteMask.sprite.rect.width, spriteMask.sprite.rect.height);

        GameObject imageObj = new GameObject("MaskedOverlayImage");
        imageObj.transform.SetParent(canvasObj.transform);
        var whiteImage = imageObj.AddComponent<Image>();
        whiteImage.maskable = true;

        RectTransform rectTransform = whiteImage.GetComponent<RectTransform>();
        rectTransform.anchorMin = Vector2.zero;
        rectTransform.anchorMax = Vector2.one;
        rectTransform.offsetMin = Vector2.zero;
        rectTransform.offsetMax = Vector2.zero;

        if (customSprite != null)
        {
            whiteImage.sprite = customSprite;
            whiteImage.color = Color.white;
            whiteImage.preserveAspect = false;
            AdjustImageFill(rectTransform, customSprite);
        }
        else
        {
            whiteImage.color = new Color(1, 1, 1, 1);
        }

        var rectMask = canvasObj.AddComponent<RectMask2D>();

        Global.main.StartCoroutine(FadeOutOverlay());

        IEnumerator FadeOutOverlay()
        {
            if (glint)
                yield return new WaitForSeconds(duration > 0.1f ? 0.1f : duration);

            float elapsedTime = 0.0f;
            while (elapsedTime < duration)
            {
                elapsedTime += Time.deltaTime;
                float alpha = Mathf.Lerp(1.0f, 0.0f, elapsedTime / duration);
                whiteImage.color = new Color(whiteImage.color.r, whiteImage.color.g, whiteImage.color.b, alpha);
                yield return null;
            }

            whiteImage.color = new Color(whiteImage.color.r, whiteImage.color.g, whiteImage.color.b, 0);
            Destroy(canvasObj);
        }

        void AdjustImageFill(RectTransform _rectTransform, Sprite sprite)
        {
            float spriteAspect = sprite.rect.width / sprite.rect.height;
            float screenAspect = (float)Screen.width / Screen.height;

            if (spriteAspect > screenAspect)
                _rectTransform.localScale = new Vector3(1, spriteAspect / screenAspect, 1);
            else
                _rectTransform.localScale = new Vector3(screenAspect / spriteAspect, 1, 1);
        }
    }


    public static void CreateOverlay(float duration = 1f, bool glint = true, Sprite customSprite = null)
    {
        GameObject canvasObj = new GameObject("WhiteOverlayCanvas");
        var whiteCanvas = canvasObj.AddComponent<Canvas>();
        canvasObj.AddComponent<CanvasScaler>();
        canvasObj.AddComponent<GraphicRaycaster>();

        whiteCanvas.renderMode = RenderMode.ScreenSpaceOverlay;
        whiteCanvas.sortingOrder = 9999;

        GameObject imageObj = new GameObject("WhiteOverlayImage");
        imageObj.transform.SetParent(canvasObj.transform);
        var whiteImage = imageObj.AddComponent<Image>();

        RectTransform rectTransform = whiteImage.GetComponent<RectTransform>();
        rectTransform.anchorMin = Vector2.zero;
        rectTransform.anchorMax = Vector2.one;
        rectTransform.offsetMin = Vector2.zero;
        rectTransform.offsetMax = Vector2.zero;

        if (customSprite != null)
        {
            whiteImage.sprite = customSprite;
            whiteImage.color = Color.white;
            whiteImage.preserveAspect = false;
            AdjustImageFill(rectTransform, customSprite);
        }
        else
            whiteImage.color = new Color(1, 1, 1, 1);

        Global.main.StartCoroutine(FadeOutWhiteOverlay());

        IEnumerator FadeOutWhiteOverlay()
        {
            if (glint)
                yield return new WaitForSeconds(duration > 0.1f ? 0.1f : duration);

            float elapsedTime = 0.0f;
            while (elapsedTime < duration)
            {
                elapsedTime += Time.deltaTime;
                float alpha = Mathf.Lerp(1.0f, 0.0f, elapsedTime / duration);
                whiteImage.color = new Color(whiteImage.color.r, whiteImage.color.g, whiteImage.color.b, alpha);
                yield return null;
            }

            whiteImage.color = new Color(whiteImage.color.r, whiteImage.color.g, whiteImage.color.b, 0);
            Destroy(whiteCanvas.gameObject);
        }

        void AdjustImageFill(RectTransform _rectTransform, Sprite sprite)
        {
            float spriteAspect = sprite.rect.width / sprite.rect.height;
            float screenAspect = (float)Screen.width / Screen.height;

            if (spriteAspect > screenAspect)
                _rectTransform.localScale = new Vector3(1, spriteAspect / screenAspect, 1);
            else
                _rectTransform.localScale = new Vector3(screenAspect / spriteAspect, 1, 1);
        }
    }


#pragma warning disable CS0618
    public static Contraption GetContraption(string name)
    {
        var Local = UnityEngine.Object.FindObjectsOfTypeAll(typeof(ItemButtonBehaviour)).Cast<ItemButtonBehaviour>().FirstOrDefault(x => x.Local.Name == name).Local;
        if (Local == null)
            return null;
        try
        {
            return ContraptionSerialiser.LoadContraption(Local);
        }
        catch (Exception message)
        {
            UnityEngine.Debug.LogError(message);
            UISoundBehaviour.Main.Error();
            DialogBoxManager.Notification(Local.IsCurrentVersion ? "This contraption is corrupted" : ("This contraption is incompatible with your current version\nTarget " + Local.Version + ", Current 1.27.5"));
            return null;
        }
    }
#pragma warning restore CS0618

    public static void CreatePlayer(string url) => new GameObject(GenerateRandomString(5)).AddComponent<VideoPlayerScript>().videoFilePath = url;

    public static int CreatePose(this PersonBehaviour perosn, bool ShouldStandUpright, float UprightForceMultiplier, float AnimationSpeedMultiplier, float Rigidity, float[] rotations)
    {
        var pose = new RagdollPose { ShouldStandUpright = ShouldStandUpright, ForceMultiplier = 1f, State = PoseState.Sitting, UprightForceMultiplier = UprightForceMultiplier, AnimationSpeedMultiplier = AnimationSpeedMultiplier, Rigidity = Rigidity, ShouldStumble = false, Angles = new List<RagdollPose.LimbPose>() };

        pose.Angles.AddRange(Enumerable.Range(0, rotations.Length).Select(i => new RagdollPose.LimbPose(perosn.Limbs[i], rotations[i])));

        pose.ConstructDictionary();

        perosn.Poses.Add(pose);
        return (perosn.Poses.Count - 1);
    }

    internal static bool IsInCone(Vector2 point, Vector2 position, Vector2 direction, float angle) => Vector2.Angle(direction, (point - position).normalized) < angle / 2f;

    public static void ResetPose(this PersonBehaviour person) => person.OverridePoseIndex = -1;

    internal static void NoChildCollide(this GameObject instance)
    {
        var componentsInChildren = instance.GetComponentsInChildren<Collider2D>();
        componentsInChildren.ForEach(collider2D => componentsInChildren.ForEach(collider2D2 => {
            if (collider2D && collider2D2 && collider2D != collider2D2)
                Physics2D.IgnoreCollision(collider2D, collider2D2);
        }));
    }
    internal static void NoChildCollide(this GameObject instance, IEnumerable<Collider2D> with)
    {
        var componentsInChildren = instance.GetComponentsInChildren<Collider2D>().Concat(with).ToArray();
        componentsInChildren.ForEach(collider2D => componentsInChildren.ForEach(collider2D2 => {
            if (collider2D && collider2D2 && collider2D != collider2D2)
                Physics2D.IgnoreCollision(collider2D, collider2D2);
        }));
    }

    public class PointDebuggerCollider : MonoBehaviour
    {
        public Collider2D Collider;
        private void Update() => ModAPI.Draw.Collider(Collider);
    }

    internal class InvokerOnStart : MonoBehaviour
    {
        public Action ActionForInvoke;

        public void Start()
        {
            ActionForInvoke.Invoke();
            Destroy(this);
        }
    }

    internal class InvokerAfterDelay : MonoBehaviour
    {
        public Action ActionForInvoke;
        public float Delay;
        private void Start() => StartCoroutine(Delayer());
        private IEnumerator Delayer()
        {
            yield return new WaitForSeconds(Delay);
            ActionForInvoke.Invoke();
            Destroy(gameObject);
        }
    }
    public class MotionBlur2D : MonoBehaviour
    {
        private TrailRenderer trailRenderer;
        private SpriteRenderer spriteRenderer;
        private Material trailMaterial;
        private Quaternion lastRotation;

        void Start()
        {
            spriteRenderer = GetComponent<SpriteRenderer>();
            if (spriteRenderer == null)
            {
                Debug.LogError("物体上没有SpriteRenderer组件！");
                return;
            }

            trailRenderer = gameObject.AddComponent<TrailRenderer>();
            trailRenderer.time = 0.1f;

            // 通过比较宽度和高度决定拖尾宽度
            float maxDimension = Mathf.Max(spriteRenderer.bounds.size.x, spriteRenderer.bounds.size.y);
            trailRenderer.startWidth = maxDimension;
            trailRenderer.endWidth = 0.0f;

            // 创建新的Texture2D并根据最大维度调整方向
            bool isWidthDominant = spriteRenderer.bounds.size.x > spriteRenderer.bounds.size.y;
            Texture2D spriteTexture = CreateSpriteTexture(spriteRenderer.sprite, isWidthDominant);
            if (spriteTexture == null)
            {
                Debug.LogError("无法创建Sprite纹理！");
                return;
            }
            trailMaterial = new Material(Shader.Find("Sprites/Default"));
            trailMaterial.mainTexture = spriteTexture;
            trailRenderer.material = trailMaterial;

            var gradient = new UnityEngine.Gradient();
            gradient.SetKeys(
                new GradientColorKey[] { new GradientColorKey(Color.white, 0.0f), new GradientColorKey(Color.white, 1.0f) },
                new GradientAlphaKey[] { new GradientAlphaKey(1.0f, 0.0f), new GradientAlphaKey(0.0f, 1.0f) }
            );
            trailRenderer.colorGradient = gradient;

            lastRotation = transform.rotation;
        }

        private Texture2D CreateSpriteTexture(Sprite sprite, bool isWidthDominant)
        {
            try
            {
                Rect rect = sprite.textureRect;
                Texture2D sourceTex = sprite.texture;

                // 创建临时的RenderTexture，尺寸根据最大维度调整
                int texWidth = (int)rect.width;
                int texHeight = (int)rect.height;
                RenderTexture rt = RenderTexture.GetTemporary(
                    texWidth,
                    texHeight,
                    0,
                    RenderTextureFormat.ARGB32
                );

                // 将sprite渲染到RenderTexture
                Graphics.Blit(sourceTex, rt, new Vector2(
                    rect.width / sourceTex.width,
                    rect.height / sourceTex.height
                ), new Vector2(
                    rect.x / sourceTex.width,
                    rect.y / sourceTex.height
                ));

                // 创建新的Texture2D
                Texture2D newTexture = new Texture2D(texWidth, texHeight, TextureFormat.RGBA32, false);
                RenderTexture.active = rt;
                newTexture.ReadPixels(new Rect(0, 0, rt.width, rt.height), 0, 0);
                newTexture.Apply();

                // 如果高度主导（即需要旋转90度）
                if (isWidthDominant)
                {
                    Texture2D rotatedTexture = new Texture2D(texHeight, texWidth, TextureFormat.RGBA32, false);
                    for (int y = 0; y < texHeight; y++)
                    {
                        for (int x = 0; x < texWidth; x++)
                        {
                            rotatedTexture.SetPixel(y, texWidth - 1 - x, newTexture.GetPixel(x, y));
                        }
                    }
                    rotatedTexture.Apply();
                    Destroy(newTexture); // 清理原始纹理
                    newTexture = rotatedTexture;
                }

                // 清理
                RenderTexture.active = null;
                RenderTexture.ReleaseTemporary(rt);

                return newTexture;
            }
            catch (System.Exception e)
            {
                Debug.LogError($"创建Sprite纹理失败: {e.Message}");
                return null;
            }
        }

        //void Update()
        //{
        //    if (trailRenderer != null)
        //    {
        //        // 获取当前拖尾的所有位置
        //        Vector3[] positions = new Vector3[trailRenderer.positionCount];
        //        int positionCount = trailRenderer.GetPositions(positions);

        //        if (positionCount > 0)
        //        {
        //            // 计算物体当前位置与上一次旋转的偏移
        //            Quaternion rotationDelta = transform.rotation * Quaternion.Inverse(lastRotation);

        //            // 将拖尾的头部位置设置为物体当前位置，确保衔接
        //            positions[0] = transform.position;

        //            // 更新其余拖尾点的位置，使其跟随旋转但保持相对距离
        //            for (int i = 1; i < positionCount; i++)
        //            {
        //                // 计算相对于物体中心的偏移向量
        //                Vector3 offset = positions[i] - transform.position;
        //                // 应用旋转变化到偏移向量
        //                offset = rotationDelta * offset;
        //                // 更新拖尾点的位置
        //                positions[i] = transform.position + offset;
        //            }

        //            // 应用更新后的位置
        //            trailRenderer.SetPositions(positions);
        //        }

        //        // 更新上一次旋转记录
        //        lastRotation = transform.rotation;
        //    }
        //}

        void OnDestroy()
        {
            // 清理创建的资源
            if (trailMaterial != null)
            {
                Destroy(trailMaterial.mainTexture);
                Destroy(trailMaterial);
            }
        }
    }

    public class AttractParticle : MonoBehaviour
    {
        ParticleSystem CoolParticle;
        ParticleSystemForceField forcefield;

        public void Awake()
        {
            InitCoolParticle();
            InitForceField();
        }

        public void InitForceField()
        {
            forcefield = base.gameObject.AddComponent<ParticleSystemForceField>();
            forcefield.gravity = 2f;
            forcefield.endRange = 6f;
            forcefield.drag = 0.2f;
        }

        public void InitCoolParticle()
        {
            GameObject CoolParticleObject = new GameObject("Cool Particles");
            CoolParticle = CoolParticleObject.AddComponent<ParticleSystem>();
            CoolParticle.transform.parent = base.transform;

            CoolParticle.transform.localPosition = Vector3.zero;
            CoolParticle.transform.localEulerAngles = Vector3.zero;

            ParticleSystem.ShapeModule shape = CoolParticle.shape;
            shape.enabled = true;
            shape.shapeType = ParticleSystemShapeType.Circle;
            shape.scale = Vector3.one * 0.3f;
            shape.randomDirectionAmount = 1f;

            ParticleSystem.MainModule main = CoolParticle.main;
            main.startLifetime = new ParticleSystem.MinMaxCurve(0.1f, 0.2f);
            main.startSpeed = new ParticleSystem.MinMaxCurve(0.2f, 0.6f);

            ParticleSystem.EmissionModule emission = CoolParticle.emission;
            emission.enabled = true;
            emission.rateOverTime = 256f;

            ParticleSystem.TrailModule trails = CoolParticle.trails;
            trails.enabled = true;
            trails.lifetime = new ParticleSystem.MinMaxCurve(0.3f, 0.4f);
            trails.ratio = 0.3f;
            trails.minVertexDistance = 0.05f;
            trails.sizeAffectsWidth = false;
            trails.colorOverTrail = new Color(0.08f, 0.08f, 0.08f);

            AnimationCurve sizeCurve = new AnimationCurve();
            sizeCurve.AddKey(0.0f, 0f);
            sizeCurve.AddKey(0.8f, 1f);
            sizeCurve.AddKey(1f, 0f);

            trails.widthOverTrail = new ParticleSystem.MinMaxCurve(0.03f, sizeCurve);
            trails.inheritParticleColor = false;
            trails.dieWithParticles = false;

            ParticleSystem.ExternalForcesModule externalForces = CoolParticle.externalForces;
            externalForces.enabled = true;

            ParticleSystemRenderer renderer = CoolParticleObject.GetOrAddComponent<ParticleSystemRenderer>();
            renderer.renderMode = ParticleSystemRenderMode.None;
            renderer.sortingLayerName = "Bubbles";
            renderer.trailMaterial = ModAPI.FindMaterial("VeryBright");
        }

        public IEnumerator End()
        {
            ParticleSystem.EmissionModule emission = CoolParticle.emission;
            emission.enabled = false;

            yield return new WaitForSeconds(0.2f);

            Destroy(base.gameObject);
        }
    }

    public class PseudoChild : MonoBehaviour
    {
        [SkipSerialisation]
        public Transform Parent;
        public bool RotationSync = true;
        public bool ScaleSync = true;
        public float DeleteAfterParentDestroy
        {
            set
            {
                needDestroy = true;
                m_deleteAfterParentDestroy = value;
            }
        }
        private float m_deleteAfterParentDestroy;
        private bool destroyed = false;
        private bool needDestroy = false;
        private void Update()
        {
            if (Parent == null)
            {
                if (!destroyed)
                {
                    StartCoroutine(DestroyAction());
                }
            }
            else
            {
                transform.position = Parent.position;
                if (ScaleSync)
                    transform.localScale = Parent.localScale;
                if (RotationSync)
                    transform.rotation = Parent.rotation;
            }
        }
        private IEnumerator DestroyAction()
        {
            destroyed = true;
            if (needDestroy)
            {
                yield return new WaitForSeconds(m_deleteAfterParentDestroy);
                gameObject.Destroy();
            }
        }
    }

    [RequireComponent(typeof(Dont))]
    [DisallowMultipleComponent]
    internal class Dont : MonoBehaviour
    {
        private void OnDisable() => enabled = true;
        private void OnDestroy() => enabled = false;
    }

    [SkipSerialisation]
    [RequireComponent(typeof(Image))]
    internal class AnimatedImage : MonoBehaviour
    {
        internal Sprite[] Sprites;
        internal Image Image;
        private int Local = 0;
        private float T = 0;
        public float TimeFrame = 0.125f;
        private void Start() { Image = gameObject.GetComponent<Image>(); }
        private void FixedUpdate()
        {
            T += Time.fixedDeltaTime;
            if (T > TimeFrame)
            {
                Local += Local >= Sprites.Count() - 1 ? -Local : 1;
                Image.sprite = Sprites[Local];
                T = 0;
            }
        }
    }

    public class VideoPlayerScript : MonoBehaviour
    {
        private VideoPlayer videoPlayer;
        private Camera mainCamera;
        public string videoFilePath;

        public void Start()
        {
            mainCamera = GameObject.Find("Main Camera").GetComponent<Camera>();
            videoPlayer = mainCamera.gameObject.GetComponent<VideoPlayer>() ?? mainCamera.gameObject.AddComponent<VideoPlayer>();
            videoPlayer.playOnAwake = false;
            videoPlayer.renderMode = VideoRenderMode.CameraNearPlane;
            videoPlayer.url = "file://" + videoFilePath; // 使用文件路径
            videoPlayer.source = VideoSource.Url; // 使用URL作为源
            videoPlayer.targetCamera = mainCamera;
            videoPlayer.audioOutputMode = VideoAudioOutputMode.Direct;
            videoPlayer.isLooping = true;
            videoPlayer.Play();
            StartCoroutine(CheckVideoState());
        }

        public IEnumerator CheckVideoState()
        {
            if (!videoPlayer.isPlaying && GameObject.Find("WORLD") == null)
            {
                videoPlayer.url = "file://" + videoFilePath;
                videoPlayer.Play();
            }
            else
                videoPlayer.Stop();
            yield return new WaitForSeconds(1);
        }

        private void OnDisable()
        {
            Destroy(gameObject);
            var newVideoPlayer = new GameObject("NewVideoPlayer");
            newVideoPlayer.AddComponent<VideoPlayerScript>().videoFilePath = videoFilePath;
        }
    }

    public class BladeSharp : MonoBehaviour, Messages.IOnBeforeSerialise, Messages.IOnAfterDeserialise, Messages.IOnGripped, Messages.IOnDrop
    {
        public class SoftConnection
        {
            [NonSerialized]
            public FrictionJoint2D joint;
            public PhysicalBehaviour phys;
            public Collider2D coll;
            [NonSerialized]
            public bool shouldBeDeleted;
            public SoftConnection(FrictionJoint2D joint, PhysicalBehaviour phys, Collider2D coll)
            {
                this.joint = joint;
                this.phys = phys;
                this.coll = coll;
                shouldBeDeleted = false;
            }
        }
        [SkipSerialisation]
        public PhysicalBehaviour PhysicalBehaviour;
        [SkipSerialisation]
        public List<Collider2D> SharpColliders = new List<Collider2D>();
        [SkipSerialisation]
        public float ConnectionStrength = 1600f;
        [SkipSerialisation]
        public float MinSpeed = 0.01f;
        [SkipSerialisation]
        public float MinSoftness = 0f;
        [SkipSerialisation]
        public Vector2 Tip = Vector2.up;
        [SkipSerialisation]
        public LayerMask LayerMask = 10752;
        [HideInInspector]
        public Guid[] SerialisableVictims = new Guid[0];
        private readonly Collider2D[] buffer = new Collider2D[16];
        private int bufferLength;
        public bool ShouldSlice = false;
        public bool SliceOnlyDeads = true;
        public bool NotCollideWithGrip = true;
        public UnityAction<GameObject> OnLimb = null;
        public PersonBehaviour gripPerson = null;
        public float SliceChance { get => m_SliceChance; set => m_SliceChance = Mathf.Clamp(value, 0, 1); }
        public float m_SliceChance;
        [SkipSerialisation]
        public readonly Dictionary<PhysicalBehaviour, SoftConnection> softConnections = new Dictionary<PhysicalBehaviour, SoftConnection>();
        private void FixedUpdate()
        {
            bool flag = PhysicalBehaviour.rigidbody.GetRelativePointVelocity(Tip).magnitude > MinSpeed;
            ProcessSoftConnections(flag, flag ? 10f : ConnectionStrength);
        }
        private void ProcessSoftConnections(bool shouldSaw = true, float connectionStrength = 2f)
        {
            softConnections.ForEach(x => x.Value.shouldBeDeleted = true);
            foreach (var sharpCollider in SharpColliders)
            {
                bufferLength = sharpCollider.OverlapCollider(new ContactFilter2D { layerMask = LayerMask, useLayerMask = true }, buffer);
                var personColliders = new Collider2D[0];

                if (gripPerson && NotCollideWithGrip)
                    personColliders = gripPerson.GetPersonColliders();

                for (int i = 0; i < bufferLength; i++)
                {
                    var collider2D = buffer[i];
                    if (!(collider2D.transform.root != transform.root) ||
                        !Global.main.PhysicalObjectsInWorldByTransform.TryGetValue(collider2D.transform, out var value) ||
                        (NotCollideWithGrip && personColliders.Contains(collider2D)))
                        continue;

                    if (softConnections.TryGetValue(value, out var value2))
                    {
                        value2.shouldBeDeleted = !value2.coll || !value2.joint || !value2.phys;
                        if (!value2.shouldBeDeleted)
                        {
                            value2.joint.anchor = value2.phys.transform.InverseTransformPoint(GetHitPoint(collider2D, sharpCollider));
                            value2.joint.maxForce = connectionStrength;
                            value2.joint.maxTorque = connectionStrength;
                        }
                    }
                    else if (shouldSaw && value.Properties.Softness >= MinSoftness)
                        SoftConnect(value, collider2D, connectionStrength, sharpCollider);
                }
            }

            while (true)
            {
                KeyValuePair<PhysicalBehaviour, SoftConnection>? keyValuePair = null;
                foreach (var softConnection2 in softConnections)
                {
                    if (softConnection2.Value.shouldBeDeleted)
                    {
                        keyValuePair = softConnection2;
                        if ((bool)softConnection2.Value.coll)
                            IgnoreCollisionStackController.IgnoreCollisionSubstituteMethod(softConnection2.Value.coll, softConnection2.Value.joint.connectedBody.GetComponent<Collider2D>(), ignore: false);
                        break;
                    }
                }
                if (keyValuePair.HasValue)
                {
                    var value3 = keyValuePair.Value;
                    if ((bool)value3.Value.joint)
                        value3.Value.joint.Destroy();
                    softConnections.Remove(value3.Key);
                    continue;
                }
                break;
            }
        }
        private void OnDisable() => OnDestroy();
        private void OnDestroy()
        {
            softConnections.ForEach(x => x.Value.joint.Destroy());
            softConnections.Clear();
        }
        public void OnBeforeSerialise() => SerialisableVictims = softConnections.Where(p => !p.Value.shouldBeDeleted && (bool)p.Value.phys && (bool)p.Value.joint && (bool)p.Value.coll).Select(p => p.Value.phys.GetComponent<SerialisableIdentity>()?.UniqueIdentity ?? default).ToArray();
        public void OnAfterDeserialise(List<GameObject> gameobjects)
        {
            var source = gameobjects.SelectMany(c => c.GetComponentsInChildren<SerialisableIdentity>());
            SerialisableVictims.ForEach(id =>
            {
                var serialisableIdentity = source.FirstOrDefault(s => s.UniqueIdentity == id);
                if (serialisableIdentity != null)
                    if (serialisableIdentity.TryGetComponent(out PhysicalBehaviour component))
                    {
                        var sharpCollider = SharpColliders.FirstOrDefault();
                        if (sharpCollider != null)
                            SoftConnect(component, component.GetComponent<Collider2D>(), 2f, sharpCollider);
                    }
            });
        }
        private void SoftConnect(PhysicalBehaviour otherPhys, Collider2D coll, float connectionStrength, Collider2D sharpCollider)
        {
            if ((bool)otherPhys && (bool)coll)
            {
                Vector2 hitPoint = GetHitPoint(coll, sharpCollider);
                var frictionJoint2D = otherPhys.gameObject.AddComponent<FrictionJoint2D>();
                frictionJoint2D.autoConfigureConnectedAnchor = true;
                frictionJoint2D.enableCollision = true;
                frictionJoint2D.maxForce = connectionStrength;
                frictionJoint2D.connectedBody = PhysicalBehaviour.rigidbody;
                frictionJoint2D.maxTorque = connectionStrength;
                frictionJoint2D.anchor = otherPhys.transform.InverseTransformPoint(hitPoint);

                IgnoreCollisionStackController.IgnoreCollisionSubstituteMethod(coll, sharpCollider);

                var n = (transform.position - otherPhys.transform.position).normalized;
                var stabbing = new Stabbing(PhysicalBehaviour, otherPhys, n, hitPoint);
                otherPhys.SendMessage("Stabbed", stabbing, SendMessageOptions.DontRequireReceiver);
                otherPhys.SendMessage("Shot", new Shot(n, hitPoint, 65), SendMessageOptions.DontRequireReceiver);
                otherPhys.SendMessage("Shot", new Shot(n, hitPoint, 75), SendMessageOptions.DontRequireReceiver);

                if (ShouldSlice && UnityEngine.Random.value > 1 - SliceChance)
                {
                    if (SliceOnlyDeads)
                        OnLimb?.Invoke(otherPhys.gameObject);
                    else
                        otherPhys.SendMessage("Slice");
                }

                gameObject.SendMessage("Lodged", stabbing, SendMessageOptions.DontRequireReceiver);
                softConnections.Add(otherPhys, new SoftConnection(frictionJoint2D, otherPhys, coll));
            }
        }
        private Vector2 GetHitPoint(Collider2D coll, Collider2D sharpCollider) => sharpCollider.ClosestPoint((Vector2)coll.ClosestPoint(transform.position));

        public void OnGripped(GripBehaviour gripper) => gripPerson = gripper.transform.root.GetComponent<PersonBehaviour>();

        public void OnDrop(GripBehaviour formerGripper)
        {
            if (formerGripper.transform.root.GetComponent<PersonBehaviour>() == gripPerson)
                gripPerson = null;
        }
    }
    public class float01
    {
        public float value { get => Mathf.Clamp01(m_value); set => m_value = value; }
        [SerializeField]
        private float m_value;
        public static implicit operator float01(float value) => new float01 { value = value };
        public static implicit operator float(float01 float01) => float01.value;
    }

    public class BurnableSpriteObject : MonoBehaviour
    {
        public static Material burnMaterial = ModAPI.FindSpawnable("Crate").Prefab.GetComponent<SpriteRenderer>().material;
        public PhysicalBehaviour referencePhys
        {
            get => m_referencePhys;
            set
            {
                if (value == null)
                {
                    isReference = false;
                    return;
                }
                isReference = true;
                m_referencePhys = value;
            }
        }
        [SerializeField]
        private PhysicalBehaviour m_referencePhys;
        [SerializeField]
        private bool isReference = false;
        public float01 BurnProgress
        {
            get => isReference ? referencePhys.BurnProgress : m_burnProgress;
            set
            {
                if (isReference) return;
                m_burnProgress = value;
            }
        }
        [SerializeField]
        private float m_burnProgress;
        private SpriteRenderer spriteRenderer;
        private void Start()
        {
            spriteRenderer = gameObject.GetComponent<SpriteRenderer>();
            spriteRenderer.material = burnMaterial;
        }
        private void Update() => spriteRenderer.material.SetFloat("_Progress", BurnProgress);
    }

    public class ChainDestroy : MonoBehaviour
    {
        public static ChainDestroy Connecter { get; private set; }
        public static Dictionary<GameObject, List<GameObject>> ChainRelation = new Dictionary<GameObject, List<GameObject>>();

        private void Awake()
        {
            Connecter = this;
            DontDestroyOnLoad(base.gameObject);
            DontDestroyOnLoad(this);
        }

        public void Contact(GameObject contactRoot, GameObject contactChild)
        {
            if (contactRoot == null || contactChild == null) return;

            if (!ChainRelation.TryGetValue(contactRoot, out var children))
                ChainRelation[contactRoot] = new List<GameObject> { contactChild };
            else if (!children.Contains(contactChild))
                children.Add(contactChild);
        }

        public void Disassociate(GameObject contactRoot, GameObject contactChild)
        {
            if (contactRoot == null || contactChild == null) return;

            ChainRelation[contactRoot]?.Remove(contactChild);
        }

        public void RemoveAllContact(GameObject contactRoot)
        {
            if (contactRoot != null)
                ChainRelation.Remove(contactRoot);
        }

        private void LateUpdate() => Sync();

        private void Sync()
        {
            ChainRelation.ForEach(chainInfo =>
            {
                chainInfo.Value.RemoveAll(child => child == null);
                if (chainInfo.Key == null)
                    chainInfo.Value.DestroyMult();
            });
            ChainRelation.RemoveAll(x => x.Key == null);
        }

        void OnDisable() => gameObject.Destroy();
        void OnDestroy() => m_connecter = CreateHelper<ChainDestroy>("ChainConnecter");
    }


    public class ActionInvoker : MonoBehaviour
    {
        public static ActionInvoker Invoker { get; private set; }
        public static event Action OnUpdate;
        public static event Action OnLateUpdate;
        public static event Action OnFixedUpdate;
        public static event Action OnQuit;
        public static Dictionary<string, List<Coroutine>> coroutines = new Dictionary<string, List<Coroutine>>();

        private void Awake()
        {
            Invoker = this;
            DontDestroyOnLoad(base.gameObject);
            DontDestroyOnLoad(this);
        }

        void Update() => InvokeActions(ref OnUpdate);
        void LateUpdate() => InvokeActions(ref OnLateUpdate);
        void FixedUpdate() => InvokeActions(ref OnFixedUpdate);
        void OnApplicationQuit() => InvokeActions(ref OnQuit);

        public void AddUpdateAction(Action action) => OnUpdate += action;
        public void AddLateUpdateAction(Action action) => OnLateUpdate += action;
        public void AddFixedUpdateAction(Action action) => OnFixedUpdate += action;
        public void AddQuitAction(Action action) => OnQuit += action;
        public void StartNamedCoroutine(string name, IEnumerator routine)
        {
            if (routine == null)
                return;
            if (!coroutines.ContainsKey(name))
                coroutines[name] = new List<Coroutine>();
            coroutines[name].Add(StartCoroutine(routine));
        }

        public void RemoveUpdateAction(Action action, Action onRemoved = null) => RemoveAction(ref OnUpdate, action, onRemoved);
        public void RemoveLateUpdateAction(Action action, Action onRemoved = null) => RemoveAction(ref OnLateUpdate, action, onRemoved);
        public void RemoveFixedUpdateAction(Action action, Action onRemoved = null) => RemoveAction(ref OnFixedUpdate, action, onRemoved);
        public void RemoveQuitAction(Action action, Action onRemoved = null) => RemoveAction(ref OnQuit, action, onRemoved);
        public void StopNamedCoroutines(string name)
        {
            if (coroutines.ContainsKey(name))
            {
                foreach (var coroutine in coroutines[name].Where(x => x != null))
                    StopCoroutine(coroutine);
                coroutines.Remove(name);
            }
        }

        void RemoveAction(ref Action actionEvent, Action action, Action onRemoved)
        {
            if (actionEvent != null)
            {
                actionEvent -= action;
                onRemoved?.Invoke();
            }
        }

        void InvokeActions(ref Action actionEvent)
        {
            if (actionEvent == null) return;

            foreach (var action in actionEvent.GetInvocationList())
            {
                try
                {
                    ((Action)action).Invoke();
                }
                catch (Exception ex)
                {
                    Debug.LogError($"ActionInvoker: Exception in action {action.Method.Name}: {ex.Message}");
                    actionEvent -= (Action)action;
                }
            }
        }

        void OnDisable() => gameObject.Destroy();
        void OnDestroy() => m_invoker = CreateHelper<ActionInvoker>("ActionInvoker");
    }

    public class FreezeController : MonoBehaviour
    {
        public static FreezeController Controller { get; private set; }
        private void Awake()
        { 
            Controller = this;
            DontDestroyOnLoad(base.gameObject);
            DontDestroyOnLoad(this);
        }
        public class FreezeInfo
        {
            public Vector2 velocity, pos, scale;
            public Quaternion rot;
            public float angularVelocity;
            public FreezeInfo(Rigidbody2D rb)
            {
                velocity = rb.velocity;
                angularVelocity = rb.angularVelocity;
                pos = rb.transform.position;
                rot = rb.transform.rotation;
                scale = rb.transform.localScale;
            }
        }
        public readonly Dictionary<Rigidbody2D, FreezeInfo> freeze = new Dictionary<Rigidbody2D, FreezeInfo>();

        public void Freeze(Rigidbody2D rb)
        {
            if (rb == null || freeze.ContainsKey(rb)) return;

            freeze[rb] = new FreezeInfo(rb);
            rb.bodyType = RigidbodyType2D.Static;
        }

        public void UnFreeze(Rigidbody2D rb)
        {
            if (rb == null || !freeze.TryGetValue(rb, out var info)) return;

            rb.bodyType = RigidbodyType2D.Dynamic;
            rb.velocity = info.velocity;
            rb.angularVelocity = info.angularVelocity;
            freeze.Remove(rb);
        }

        public void Update() => CleanAndApply();

        public void LateUpdate() => CleanAndApply();

        private void CleanAndApply()
        {
            var toRemove = new List<Rigidbody2D>();
            freeze.ForEach(entry =>
            {
                if (entry.Key == null)
                    toRemove.Add(entry.Key);
                else
                {
                    var obj = entry.Key.transform;
                    var info = entry.Value;
                    obj.position = info.pos;
                    obj.rotation = info.rot;
                    obj.localScale = info.scale;
                }
            });
            foreach (var rb in toRemove)
                freeze.Remove(rb);
        }

        void OnDisable() => gameObject.Destroy();
        void OnDestroy() => m_controller = CreateHelper<FreezeController>("ActionInvoker");
    }

    public class SlowBehaviour : MonoBehaviour
    {
        public float TimeScaleMultiplier;
        public static SlowBehaviour Slower { get; private set; }

        public readonly Dictionary<GameObject, SlowInfo> slowedObjects = new Dictionary<GameObject, SlowInfo>();
        public readonly Dictionary<ParticleSystem, SlowInfo> slowedParticles = new Dictionary<ParticleSystem, SlowInfo>();
        public readonly Dictionary<AudioSource, SlowInfo> slowedAudio = new Dictionary<AudioSource, SlowInfo>();

        private void Awake()
        {
            Slower = this;
            DontDestroyOnLoad(base.gameObject);
            DontDestroyOnLoad(this);
        }

        public void Clear()
        {
            foreach (var particleSystem in slowedParticles.Keys.ToList())
                RemoveSlowParticle(particleSystem);

            foreach (var audioSource in slowedAudio.Keys.ToList())
                RemoveSlowAudio(audioSource);

            foreach (var gameObject in slowedObjects.Keys.ToList())
                RemoveSlowEffect(gameObject);
        }

        public void ApplySlowParticle(ParticleSystem particleSystem)
        {
            if (particleSystem == null || slowedParticles.ContainsKey(particleSystem)) return;

            var main = particleSystem.main;
            slowedParticles[particleSystem] = new SlowInfo(main.simulationSpeed);
            main.simulationSpeed /= TimeScaleMultiplier;
        }

        public void RemoveSlowParticle(ParticleSystem particleSystem)
        {
            if (particleSystem == null || !slowedParticles.TryGetValue(particleSystem, out var slowInfo)) return;

            var main = particleSystem.main;
            main.simulationSpeed = slowInfo.SimulationSpeed;
            slowedParticles.Remove(particleSystem);
        }

        public void ApplySlowAudio(AudioSource audioSource)
        {
            if (audioSource == null || slowedAudio.ContainsKey(audioSource)) return;

            slowedAudio[audioSource] = new SlowInfo(audioSource, TimeScaleMultiplier);
        }

        public void RemoveSlowAudio(AudioSource audioSource)
        {
            if (audioSource == null || !slowedAudio.TryGetValue(audioSource, out var slowInfo)) return;

            audioSource.pitch = slowInfo.OriginalSound;
            slowedAudio.Remove(audioSource);
        }

        private void Update()
        {
            foreach (var audioSource in slowedAudio.Keys.ToList())
            {
                if (audioSource == null)
                    slowedAudio.Remove(audioSource);
                else
                    slowedAudio[audioSource].UpdateSoundPitch();
            }
        }

        public void ApplySlowEffect(GameObject other)
        {
            if (other == null || slowedObjects.ContainsKey(other)) return;

            var rb = other.GetComponent<Rigidbody2D>();
            if (rb == null || rb.bodyType == RigidbodyType2D.Static) return;

            var phys = other.GetComponent<PhysicalBehaviour>();
            var slowInfo = phys != null ? new SlowInfo(phys.rigidbody.gravityScale, phys.TrueInitialMass, TimeScaleMultiplier) : new SlowInfo(rb.gravityScale, rb.mass, TimeScaleMultiplier);
            slowedObjects[other] = slowInfo;

            float slowMultiplier = TimeScaleMultiplier;

            if (phys != null)
            {
                ApplySlowAudio(phys.MainAudioSource);

                phys.InitialMass *= slowMultiplier;
                phys.TrueInitialMass *= slowMultiplier;
                rb.mass *= slowMultiplier;
                rb.velocity /= slowMultiplier;
                rb.angularVelocity /= slowMultiplier;
                phys.rigidbody.gravityScale /= slowMultiplier * 6f;
                phys.InitialGravityScale /= slowMultiplier * 6f;

                if (other.TryGetComponent(out LimbBehaviour limb))
                {
                    limb.ImpactDamageMultiplier /= slowMultiplier * 2f;
                    limb.GForceDamageThreshold *= slowMultiplier;
                    limb.GForcePassoutThreshold *= slowMultiplier;
                    limb.BaseStrength /= slowMultiplier;
                }

                if (other.TryGetComponent(out DestroyableBehaviour destroyable))
                    destroyable.MinimumImpactForce /= slowMultiplier;
            }
            else
            {
                rb.mass *= slowMultiplier;
                rb.velocity /= slowMultiplier;
                rb.angularVelocity /= slowMultiplier;
                rb.gravityScale /= slowMultiplier * 6f;
            }
        }

        public void RemoveSlowEffect(GameObject other)
        {
            if (other == null || !slowedObjects.TryGetValue(other, out var slowInfo)) return;

            var rb = other.GetComponent<Rigidbody2D>();
            if (rb == null || rb.bodyType == RigidbodyType2D.Static) return;

            var phys = other.GetComponent<PhysicalBehaviour>();

            if (phys != null)
            {
                phys.InitialMass = slowInfo.InitialMassScale;
                phys.TrueInitialMass = slowInfo.InitialMassScale;
                rb.mass = slowInfo.InitialMassScale;
                phys.rigidbody.gravityScale = slowInfo.InitialGravityScale;
                phys.InitialGravityScale = slowInfo.InitialGravityScale;

                rb.velocity *= 1.6f * TimeScaleMultiplier;
                rb.angularVelocity *= 1.6f * TimeScaleMultiplier;

                if (other.TryGetComponent(out LimbBehaviour limb))
                {
                    limb.ImpactDamageMultiplier *= TimeScaleMultiplier * 2f;
                    limb.GForceDamageThreshold /= TimeScaleMultiplier;
                    limb.GForcePassoutThreshold /= TimeScaleMultiplier;
                    limb.BaseStrength *= TimeScaleMultiplier;
                }

                if (other.TryGetComponent(out DestroyableBehaviour destroyable))
                    destroyable.MinimumImpactForce *= TimeScaleMultiplier;

                RemoveSlowAudio(phys.MainAudioSource);
            }
            else
            {
                rb.mass = slowInfo.InitialMassScale;
                rb.velocity *= 1.6f * TimeScaleMultiplier;
                rb.angularVelocity *= 1.6f * TimeScaleMultiplier;
                rb.gravityScale = slowInfo.InitialGravityScale;
            }

            slowedObjects.Remove(other);
        }

        void OnDisable() => gameObject.Destroy();
        void OnDestroy() => m_slower = CreateHelper<SlowBehaviour>("Slower");
    }

    public class SlowInfo
    {
        public AudioSource audioSource;
        public float InitialGravityScale;
        public float InitialMassScale;
        public float OriginalSound;
        public float TimeScaleMultiplier;
        public float SimulationSpeed;
        public float LifeTime;

        public SlowInfo(float initialGravityScale, float initialMassScale, float timeScaleMultiplier)
        {
            InitialGravityScale = initialGravityScale;
            InitialMassScale = initialMassScale;
            TimeScaleMultiplier = timeScaleMultiplier;
        }

        public SlowInfo(float simulationSpeed) => SimulationSpeed = simulationSpeed;

        public SlowInfo(AudioSource audioSource, float timeScaleMultiplier)
        {
            this.audioSource = audioSource;
            TimeScaleMultiplier = timeScaleMultiplier;
            OriginalSound = audioSource.pitch;
        }

        public void UpdateSoundPitch() => audioSource.pitch = OriginalSound / TimeScaleMultiplier;
    }



    [RequireComponent(typeof(AntiDestroy))]
    [DisallowMultipleComponent]
    [SkipSerialisation]
    internal class AntiDestroy : MonoBehaviour
    {
        private void OnDisable() => enabled = true;
        private void OnDestroy() => OnDisable();
    }

    [RequireComponent(typeof(BeBeing), typeof(HingeJoint2D), typeof(PhysicalBehaviour))]
    [SkipSerialisation]
    internal class BBHelper : AntiDestroy { }

    [RequireComponent(typeof(BBHelper), typeof(SpriteRenderer), typeof(Collider2D))]
    [SkipSerialisation]
    internal class BeBeing : AntiDestroy { }

    [RequireComponent(typeof(PersonBehaviour), typeof(AntiDestroyPersonBeh))]
    [SkipSerialisation]
    internal class AntiDestroyPersonBeh : MonoBehaviour { }

    public class ObjectInfo
    {
           public GameObject Instance { get; private set; }
        private Vector3 localSacle;
        public bool antiGravity { get; private set; } = true;
        public bool IsAndroid { get; private set; } = true;
        private Vector2 localGravity = new Vector2(0f, -9.81f);
        private PhysicalProperties Properties = ModAPI.FindPhysicalProperties("Incredible");
        private Dictionary<LimbBehaviour, BodyInfo> BodiesInfo = new Dictionary<LimbBehaviour, BodyInfo>();
        private List<Type> except = null;
        private Action<GameObject> OnIntegrate = null;
        private bool _isStanding = false, _coolEffect = false;
        private EffectSetting? Effect = null;
        public List<LimbBehaviour> Limbs => Instance.GetLimbs();
        public ObjectInfo(GameObject Instance, bool antiGravity = true, bool IsAndroid = true, Vector2? gravity = null, EffectSetting? Effect = null, List<Type> except = null, Action<GameObject> OnIntegrate = null, bool DontFlipJoint = false)
        {
            this.Instance = Instance;
            Instance.GetOrAddComponent<AntiDestroyPersonBeh>();
            this.localSacle = Instance.transform.localScale;
            this.antiGravity = antiGravity;
            this.localGravity = gravity.HasValue ? gravity.Value : localGravity;
            this.IsAndroid = IsAndroid;
            this.Effect = Effect;
            this._coolEffect = Effect.HasValue;
            this.OnIntegrate = OnIntegrate;
            Instance.GetPerson()?.RemoveFromDictionary();
            Limbs.ForEach(limb =>
            {
                limb.gameObject.GetOrAddComponent<BeBeing>();
                limb.gameObject.GetOrAddComponent<BBHelper>();
                limb.gameObject.BetterDestroy<ShatteredObjectGenerator>();
                limb.gameObject.BetterDestroy<ShatteredObjectSpriteInitialiser>();
                limb.gameObject.BetterDestroy<ConnectedNodeBehaviour>();
                limb.gameObject.BetterDestroy<GoreStringBehaviour>();
                if (limb.TryGetComponent(out HingeJoint2D Joint))
                {
                    Joint.autoConfigureConnectedAnchor = false;
                    limb.Joint = Joint;
                    limb.HasJoint = Joint.connectedBody != null;
                }
                BodiesInfo[limb] = new BodyInfo(Instance, limb, DontFlipJoint);
                if (_coolEffect)
                {
                    BodiesInfo[limb]._progress = 1f;
                    BodiesInfo[limb].speed = Effect.Value.Speed;
                    BodiesInfo[limb].Loop = false;
                }
                NextFrameCoroutine(() => BodiesInfo[limb].Attach());
                LimbBehaviourManager.Limbs.Remove(limb);
            });
            this.Properties = UnityEngine.Object.Instantiate(Limbs[0].PhysicalBehaviour.Properties);
            Properties.Softness = 0;
            Properties.Flammability = 0;
            Properties.MagneticAttractionIntensity = 0;
            Properties.BurningTemperatureThreshold = NaN;
            Properties.Burnrate = 0;
            Properties.Conducting = false;
            //Properties.VaporisationTemperatureThreshold = NaN;
            Properties.ShotImpact = (IsAndroid ? null : new GameObject("NULL"));
            this.except = except;
            ((Instance.TryGetComponent(out DisintegrationCounterBehaviour cnter) ? cnter : null) ?? throw new NullReferenceException("LoL")).Destroy();
            NextFrameCoroutine(() => FakeInvincible());
            if (_coolEffect)
                NextFrameCoroutine(() =>
                {
                    var start = Effect.Value.startBody ?? new[] { Limbs[0]?.Person?.GetHead() ?? Limbs[0] };
                    var visited = new List<LimbBehaviour>();
                    visited.AddRange(start);
                    start.ForEach(l => BodiesInfo[l].Loop = true);
                    start.ForEach(x => x.ConnectedLimbs.ForEach(y => y.StartCoroutine(simpleDFS(y, () => BodiesInfo[x]._progress < Effect.Value.StartProgress))));
                    IEnumerator simpleDFS(LimbBehaviour limb, Func<bool> action)
                    {
                        if (visited.Contains(limb))
                            yield break;
                        visited.Add(limb);
                        yield return new WaitUntil(() => action());
                        BodiesInfo[limb].Loop = true;
                        limb.ConnectedLimbs.ForEach(x => x.StartCoroutine(simpleDFS(x, () => BodiesInfo[limb]._progress < Effect.Value.StartProgress)));
                        limb.StopAllCoroutines();
                        yield break;
                    }
                });
        }

        public void Invincible()
        {
            if (!Instance.activeSelf)
                Instance.NoChildCollide();
            Instance.SetActive(true);

            Instance.transform.localScale = localSacle;

            if (Instance.TryGetComponent<PersonBehaviour>(out var Person))
            {
                Person.enabled = true;
                Person.Heartbeat = IntMax;
                Person.Braindead = false;
                Person.BrainDamaged = false;
                Person.BrainDamagedTime = 0;
                Person.SeizureTime = 0;
                Person.ShockLevel = 0;
                Person.PainLevel = 0;
                Person.AdrenalineLevel = 1;
                Person.Consciousness = 1;
                Person.ImpactEffectShotDamageThreshold = 0;
                Person.OxygenLevel = 1;
                Person.Limbs = Limbs.ToArray();
                var Distance = ((Vector2)Limbs.GetAveragePosition()).GetDistanceFromGround(Instance.transform).distance;
                if ((Person.ActivePose.State == PoseState.Protective || Person.ActivePose.State == PoseState.Flailing || Person.ActivePose.State == PoseState.Stumbling) && Distance > 20f)
                {
                    Person.OverridePoseIndex = 0;
                    _isStanding = true;
                }
                else if (_isStanding && Distance < 20f)
                {
                    Person.OverridePoseIndex = -1;
                    _isStanding = false;
                }
                //Person.SetPrivateProperty("IsTouchingFloor", true); // 用于巨大化的人类
                CheckComponent(Person.gameObject, except);
            }

            foreach (var limb in Limbs)
            {
                limb.enabled = true;
                limb.SpeciesIdentity = null;
                var bodyInfo = BodiesInfo[limb];

                if (limb.PhysicalBehaviour.isDisintegrated || !limb.gameObject.activeSelf)
                {
                    limb.PhysicalBehaviour.Integrate();
                    OnIntegrate(limb.gameObject);
                    bodyInfo.limbStatus.Status.SetActive(Global.main.ShowLimbStatus);
                    if (_coolEffect)
                    {
                        BodiesInfo[limb]._progress = 1f;
                        var visited = new List<LimbBehaviour>();
                        void dfs(LimbBehaviour l, int depth = 1)
                        {
                            if (visited.Contains(l))
                                return;
                            visited.Add(l);
                            l.ConnectedLimbs.ForEach(x =>
                            {
                                if (BodiesInfo[x]._progress < 1f / Mathf.Pow(1.35f, depth))
                                    BodiesInfo[x]._progress = 1f / Mathf.Pow(1.35f, depth);
                                dfs(x, depth + 1);
                            });
                        }
                        dfs(limb);
                    }
                    BodiesInfo.Values.Where(x => x.connectedLimb == limb).ForEach(x => NextFrameCoroutine(() => x.Attach()));
                    Instance.NoChildCollide();
                }

                if (!limb.transform.parent.gameObject.activeSelf)
                {
                    var Parent = limb.transform.parent;
                    while (Parent != null)
                    {
                        Parent.gameObject.SetActive(true);
                        Parent = Parent.parent;
                    }
                    limb.transform.parent.gameObject.ForEach<LimbBehaviour>(l => BodiesInfo.Values.Where(x => x.connectedLimb == l).ForEach(x => NextFrameCoroutine(() => x.Attach())));
                    Instance.NoChildCollide();
                }

                if (limb.TryGetComponent(out HingeJoint2D Joint))
                {
                    Joint.breakForce = Inf;
                    Joint.breakTorque = Inf;
                    Joint.enabled = Joint.connectedBody != null;
                }
                else NextFrameCoroutine(() => BodiesInfo[limb].Attach());


                if (limb.PhysicalBehaviour.Properties != Properties)
                    limb.PhysicalBehaviour.Properties = Properties;

                limb.PhysicalBehaviour.SimulateTemperature = false;
                limb.FreezingTemperature = NaN;
                limb.DiscomfortingHeatTemperature = NaN;
                limb.BodyTemperature = NaN;
                limb.InternalTemperature = NaN;
                limb.PhysicalBehaviour.Temperature = NaN;
                limb.PhysicalBehaviour.InitialGravityScale = 1;
                limb.PhysicalBehaviour.rigidbody.gravityScale = 1;
                limb.PhysicalBehaviour.rigidbody.drag = 0.05f;
                limb.PhysicalBehaviour.rigidbody.angularDrag = 0.05f;
                limb.PhysicalBehaviour.Disintegratable = false;
                limb.PhysicalBehaviour.Deletable = false;
                limb.PhysicalBehaviour.Resizable = false;
                limb.PhysicalBehaviour.Selectable = true;
                limb.PhysicalBehaviour.BurnIntensity = 0;
                limb.PhysicalBehaviour.Extinguish();
                limb.PhysicalBehaviour.ChargeBurns = false;
                limb.PhysicalBehaviour.ForceNoCharge = true;
                limb.PhysicalBehaviour.ForceNoChargeParticles = true;
                limb.PhysicalBehaviour.EnergyWireResistance = Inf;
                limb.CirculationBehaviour.BleedingRate = 0;
                limb.CirculationBehaviour.InternalBleedingIntensity = 0;
                limb.PhysicalBehaviour.ReflectsLasers = true;
                limb.PhysicalBehaviour.BulletPenetration = false;
                limb.PhysicalBehaviour.ConductOverride = false;

                limb.SkinMaterialHandler.intensityMultiplier = 0;
                limb.SkinMaterialHandler.enabled = true;
                limb.SkinMaterialHandler.ShouldRot = false;
                limb.PhysicalBehaviour.BurnProgress = 0;
                limb.SkinMaterialHandler.renderer.material.SetFloat("_AcidProgress", BodiesInfo[limb]._progress);
                limb.SkinMaterialHandler.renderer.material.SetFloat("_RottenProgress", 0);
                for (int i = 0; i < limb.SkinMaterialHandler.damagePoints.Length; i++)
                    limb.SkinMaterialHandler.damagePoints[i] = DamagePoint.None;
                limb.SkinMaterialHandler.currentDamagePointCount = 0;
                limb.SkinMaterialHandler.ClearAllDamage();
                limb.SkinMaterialHandler.Sync();

                limb.CirculationBehaviour.HealBleeding();
                limb.CirculationBehaviour.AddLiquid(limb.GetOriginalBloodType(), Inf);
                limb.CirculationBehaviour.ForceSetAllLiquid(Inf);
                limb.CirculationBehaviour.ImmuneToDamage = true;
                limb.CirculationBehaviour.IsDisconnected = false;
                limb.CirculationBehaviour.GunshotWoundCount = 0;
                limb.CirculationBehaviour.StabWoundCount = 0;
                limb.CirculationBehaviour.IsPump = limb.CirculationBehaviour.WasInitiallyPumping;
                limb.CirculationBehaviour.BloodFlow = Inf;

                limb.Collider.enabled = !_coolEffect || BodiesInfo[limb]._progress < 1f;

                limb.FakeUprightForce = limb.RoughClassification != LimbBehaviour.BodyPart.Arms ? 0.002f : 0.001f;
                limb.RegenerationSpeed = IntMax;
                limb.InitialHealth = FloatMax;
                limb.Health = Inf;
                limb.BreakingThreshold = Inf;
                limb.IsDismembered = false;
                limb.ImmuneToDamage = true;
                limb.VitalParts = new Bounds[] { };
                limb.SetNode(true);
                limb.ShotDamageMultiplier = 0;
                limb.ImpactDamageMultiplier = 0;
                limb.DoStumble = false;
                limb.BloodDecal = null;
                limb.LungsPunctured = false;
                limb.IsLethalToBreak = false;
                limb.NodeBehaviour.IsRoot = true;
                limb.Numbness = 0;
                limb.HasBrain = false;
                limb.HasLungs = false;
                limb.IsAndroid = IsAndroid;
                limb.IsZombie = false;
                limb.Frozen = false;
                limb.Vitality = 0f;
                limb.BruiseCount = 0;
            }

            HealBone();

            BodiesInfo.Values.ForEach(x => x.Locked());

            Instance.ForEach<Rigidbody2D>(rigidbody =>
            {
                if (rigidbody.bodyType != RigidbodyType2D.Dynamic && !rigidbody.GetComponent<FreezeBehaviour>() && !rigidbody.GetComponent<Optout>())
                    rigidbody.bodyType = RigidbodyType2D.Dynamic;
            });

            CheckComponent(Instance, except);
        }

        public void FakeInvincible()
        {
            BodiesInfo.ForEach(status =>
            {
                var data = status.Value.limbStatus;
                data.Status.SetActive(Global.main.ShowLimbStatus);
                data.Status.transform.localScale = Vector3.Scale(status.Key.transform.localScale, localSacle);
                var Beh = data.Beh;
                Beh.enabled = false;
                if (Beh.SpriteRenderer.isVisible)
                {
                    Beh.SpriteRenderer.sprite = BarSprite;
                    var Bar = Beh.Bar;
                    Bar.localScale = new Vector3(0.2571428571428571f, 0.028571428571429f);
                    Bar.localPosition = Vector3.zero;
                    Bar.gameObject.SetActive(true);
                }
            });
        }

        public void HealBone() => Limbs.Where(x => x.Broken).ForEach(x => x.HealBone());

        public void Update() => Limbs.ForEach(l => l.ManagedUpdate());
        public void LateUpdate() => Limbs.ForEach(l => l.ManagedLateUpdate());
        public void FixedUpdate() => Limbs.ForEach(l => l.ManagedFixedUpdate());

        public void AntiGravity() => Instance.ForEach<Rigidbody2D>(rigidbody => rigidbody.AddForce(rigidbody.mass * (localGravity - Physics2D.gravity) * (antiGravity ? 1f : 0f)));

        public class BodyInfo
        {
            private GameObject Instance;
            public (GameObject Status, LimbStatusBehaviour Beh) limbStatus;
            public LimbBehaviour limb, connectedLimb;
            public Vector3 localScale;
            public Vector2 anchor, connectedAnchor;
            public Vector2 limits;
            public Color color;
            public bool useLimits, Loop = true, flipJoint;
            public float mass, strength;
            [Range(0f, 1f)]
            public float _progress = 0f;
            [Range(0f, 1f)]
            public float speed = 0.08f;

            public BodyInfo(GameObject Instance, LimbBehaviour limb, bool Flip)
            {
                this.Instance = Instance;
                this.limb = limb;
                TryCatchAction(() =>
                {
                    var status = limb.GetPrivate<GameObject>("myStatus");
                    var behaviour = status.GetComponent<LimbStatusBehaviour>();
                    behaviour.InvokePrivateMethod("Start", null);
                    limbStatus = (status, behaviour);
                });
                this.mass = limb.PhysicalBehaviour.TrueInitialMass;
                this.strength = limb.BaseStrength;
                this.color = limb.Color;
                this.localScale = limb.transform.localScale;
                this.connectedLimb = limb.Joint.connectedBody?.GetComponent<LimbBehaviour>();
                this.anchor = limb.Joint.anchor;
                this.connectedAnchor = limb.Joint.connectedAnchor;
                this.flipJoint = Flip;
                this.limits.x = IsFlipped ? -limb.Joint.limits.max : limb.Joint.limits.min;
                this.limits.y = IsFlipped ? -limb.Joint.limits.min : limb.Joint.limits.max;
                this.useLimits = limb.Joint.useLimits;
                this.limb.SetPrivate("originalJointLimits", this.limits);
                Invoker.AddLateUpdateAction(() => this._progress = Loop ? Mathf.SmoothStep(this._progress, 0f, speed) : this._progress);

            }

            public void Locked()
            {
                limb.Color = color;
                limb.transform.localScale = localScale;
                limb.PhysicalBehaviour.TrueInitialMass = limb.PhysicalBehaviour.rigidbody.mass = mass;
                limb.BaseStrength = strength;
                limb.PhysicalBehaviour.RecalculateMassBasedOnSize();
                mass = limb.PhysicalBehaviour.TrueInitialMass;
                strength = limb.BaseStrength;
            }

            private bool IsFlipped => Instance.transform.localScale.x < 0 && !flipJoint;

            public void Attach()
            {
                var joint = limb.gameObject.AddComponent<HingeJoint2D>();
                limb.Joint.Destroy();
                Rigidbody2D rigidbody = limb.PhysicalBehaviour.rigidbody, connectedBody = connectedLimb?.PhysicalBehaviour.rigidbody;
                rigidbody.rotation = connectedBody != null ? connectedBody.rotation : 0f;

                joint.connectedBody = connectedBody;
                joint.autoConfigureConnectedAnchor = false;
                joint.anchor = anchor;
                joint.connectedAnchor = connectedAnchor;
                joint.limits = limits.ToLimits();
                joint.useLimits = useLimits;
                joint.useMotor = true;
                joint.motor = new JointMotor2D { maxMotorTorque = limb.MotorStrength, motorSpeed = 0f };
                limb.Joint = joint;
                limb.SetPrivate("originalJointLimits", limits);
                limb.CirculationBehaviour.IsDisconnected = false;
                if (connectedLimb != null && connectedLimb.CirculationBehaviour != limb.CirculationBehaviour.Source)
                    connectedLimb.CirculationBehaviour.IsDisconnected = false;
                limb.CirculationBehaviour.IsDisconnected = false;
                limb.HasJoint = connectedBody != null;
            }
        }
    }

    public struct EffectSetting
    {
        public float Speed;
        public float StartProgress;
        public LimbBehaviour[] startBody;
        public EffectSetting(float speed, float when, params LimbBehaviour[] startBody)
        {
            this.startBody = startBody;
            this.Speed = speed;
            this.StartProgress = when;
        }
    }

    public class InvincibleHelper : MonoBehaviour
    {
        private void Awake()
        {
            Helper = this;
            DontDestroyOnLoad(base.gameObject);
            DontDestroyOnLoad(this);
            Setup();
        }

        public static InvincibleHelper Helper { get; private set; }
        private static List<ObjectInfo> Instances => (InvincibleTargets.RemoveAll(x => x.Instance == null || x.Limbs.Count == 0), InvincibleTargets).Item2;

        public void Add(ObjectInfo info)
        {
            if (!HasInstance(info.Instance))
                InvincibleTargets.Add(info);
            Setup();
        }

        public void Remove(GameObject instance) => InvincibleTargets.RemoveAll(x => x.Instance == instance);
        public bool HasInstance(GameObject obj) => Instances.Any(x => x.Instance == obj.transform.root.gameObject);

        private void Setup() => Instances.ForEach(x => x.Invincible());

        private void Update() => Instances.ForEach(x => { x.Update(); x.Invincible(); });

        private void LateUpdate() => Instances.ForEach(x => { x.LateUpdate(); x.Invincible(); });

        private void FixedUpdate() => Instances.ForEach(x => { x.HealBone(); x.FixedUpdate(); x.FakeInvincible(); if (x.antiGravity) x.AntiGravity(); });

        void OnDisable() => gameObject.Destroy();
        void OnDestroy() => m_helper = CreateHelper<InvincibleHelper>("InvincibleHelper");
    }
}
#pragma warning restore CS0612
#pragma warning restore CS0618
